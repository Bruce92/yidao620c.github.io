<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类目录：rabbitmq | 笨跑的一刀]]></title>
  <link href="http://yidao620c.github.io/blog/categories/rabbitmq/atom.xml" rel="self"/>
  <link href="http://yidao620c.github.io/"/>
  <updated>2015-05-17T20:07:25+08:00</updated>
  <id>http://yidao620c.github.io/</id>
  <author>
    <name><![CDATA[熊能]]></name>
    <email><![CDATA[yidao620@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用python开发RabbitMQ应用]]></title>
    <link href="http://yidao620c.github.io/blog/20150420/rabbitmq-python-client.html"/>
    <updated>2015-04-20T11:21:34+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150420/rabbitmq-python-client</id>
    <content type="html"><![CDATA[<p>参考了RabbitMQ网站上提供的英文版本入门指南: <a href="http://www.rabbitmq.com/getstarted.html">http://www.rabbitmq.com/getstarted.html</a></p>

<p>测试环境：CentOS 6.2</p>

<p><strong>1，测试环境准备</strong></p>

<p>安装python（一般系统都自带了python）</p>

<p>安装RabbitMQ server可以参考前面的文章。</p>

<p>安装pika</p>

<p>使用pip安装的时候可能会报错：</p>

<p><code>importerror no module named pkg_resources</code></p>

<p>请用下面命令解决这个问题：
<code>
$ curl https://bitbucket.org/pypa/setuptools/raw/bootstrap/ez_setup.py | python
</code></p>

<p>然后还可能出现：</p>

<p><code>pkg_resources.distributionnotfound pip==1.4.1</code></p>

<p>这时候先把pip卸载掉，执行：
<code>
sudo yum remove python-pip
</code>
然后去下载最新的get-pip.py文件，执行<code>python get-pip.py</code>安装</p>

<p>在<code>/etc/profile</code>里面将<code>/usr/local/python27/bin</code>加入PATH最前面<!--more--></p>

<p>把rabbitmq server启动一下和准备好测试目录rabbitmq_app：
<code>
$ /usr/local/rabbitmq/sbin/rabbitmq-server -detached
$ cd ~
$ mkdir -p test /rabbitmq_app
$ cd test /rabbitmq_app
$ mkdir tut1 tut2 tut3 tut4 tut5 tut6
</code></p>

<p><strong>2，实例一：来个hello world程序</strong>
<code>
$ cd tut1
$ vim send.py (代码如下)
$ vim receive.py (代码如下)
</code></p>

<p>首先是消息发送程序: send.py
<code>python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import sys
import pika
connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()
channel.queue_declare(queue = 'hello')
if len (sys.argv) &lt; 2 :
     print 'message is empty!'
     sys.exit(0)
message = sys.argv[1]
channel.basic_publish(exchange = '', routing_key='hello', body = message)
print "[x] sent: '" + message + "'\n"
connection.close()
</code>
跑一下send.py发送一个消息
<code>
$ python send.py ‘Hello World!’
$ python send.py ‘你好刀哥’
$ /usr/local/rabbitmq/sbin/rabbitmqctl list_queues
</code>
结果如下面：</p>

<pre><code>Listing queues …
hello 2
… done .
</code></pre>

<p>如果你也看到hello队列里面有一个消息的话，就证明可以发消息了。</p>

<p>然后写一个接收消息脚本：receive.py
&#8220;` python
#!/usr/bin/env python
# -<em>- coding: utf-8 -</em>-
import pika
connection = pika.BlockingConnection(pika.ConnectionParameters( ‘localhost’ ))
channel = connection.channel()
channel.queue_declare(queue = ‘hello’ )
print ‘[*] Waiting for messages. To exit press CTRL+C’</p>

<p>def callback(ch, method, properties, body):
     print body</p>

<p>channel.basic_consume(callback, queue = ‘hello’ , no_ack = True )
channel.start_consuming()
&#8220;`
其中第12行的 no_ack=True 表示消费完了这个消息以后不主动把完成状态通知rabbitmq。</p>

<p>然后开另外一个shell，执行一下receive.py
<code>
$ python receive.py
</code>
结果：</p>

<pre><code>[*] Waiting for messages. To exit press CTRL+C
Hello World!
你好刀哥
</code></pre>

<p><strong>3，实例二：工作队列（work queue / task queue）</strong></p>

<p>一般应用于把比较耗时的任务从主线任务分离出来。比如一个http页面请求，
里面需要发送带大附件的邮件、或者是要处理一张头像图片等。这类型工作队列的处理端一般有多个worker进程，
分担队列里面的任务。这就有点负载均衡的策略在里面了。
尽量做到每个进程的工作量比较平均，而且是完成了一个任务才接 第二个任务。看看我们的实现吧。
<code>
$ cd tut2
$ vim manager.py (代码如下)
$ vim worker.py (代码如下)
</code>
首先是消息发送程序: manager.py
<code>python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import pika
import sys
parameters = pika.ConnectionParameters(host = 'localhost' )
connection = pika.BlockingConnection(parameters)
channel = connection.channel()
channel.queue_declare(queue = 'task_queue' , durable = True )
message = ' ' .join(sys.argv[ 1 :]) or "Hello World!"
channel.basic_publish(exchange = '',
                       routing_key = 'task_queue' ,
                       body = message,
                       properties = pika.BasicProperties(
                          delivery_mode = 2 , # make message persistent
                       ))
print " [x] Sent %r" % (message,)
connection.close()
</code>
其中第8行的 durable=True 声明了队列需要持久化，第14行的 delivery_mode = 2 声明了队列的消息需要持久化。</p>

<p>然后写一个接收消息脚本：worker.py
&#8220;` python
#!/usr/bin/env python
# -<em>- coding: utf-8 -</em>-
import pika
import time
connection = pika.BlockingConnection(pika.ConnectionParameters(
         host = ‘localhost’ ))
channel = connection.channel()
channel.queue_declare(queue = ‘task_queue’ , durable = True )
print ‘ [*] Waiting for messages. To exit press CTRL+C’</p>

<p>def callback(ch, method, properties, body):
     print “ [x] Received %r” % (body,)
     time.sleep( body.count( ‘.’ ) )
     print “ [x] Done”
     ch.basic_ack(delivery_tag = method.delivery_tag)</p>

<p>channel.basic_qos(prefetch_count = 1 )
channel.basic_consume(callback,
                       queue = ‘task_queue’ )
channel.start_consuming()
&#8220;`
其中第15行的 basic_ack 是执行完任务通知rabbitmq，
第17行的basic_qos是告诉rabbitmq只有当worker完成了任务以后才分派1条新的消息，实现公平分派。</p>

<p>测试方法，开3个bash，2个跑worker，1个跑manager：
<code>
$ python manager.py task1.
$ python manager.py task2..
$ python manager.py task3…
$ python manager.py task4….
</code>
点号数量决定worker工作的时间( 其实是睡觉时间，呵呵 time.sleep(body.count(‘.’)) )。
而在worker那边，可以看到每个worker都处理了两个任务。
这种分配机制就是所谓的循环调度（Round-robin dispatching）</p>

<p><strong>4，实例三：发布和订阅</strong></p>

<p>发布订阅模式，简单来说就像是广播，一个消息发布出来以后，所有订阅者都能听到，
至于接收到这个信息以后大家做什么就看具体个人了。</p>

<p>啊！怎么忽然冒出个X，是什么玩意！这个X就是所谓的exchange，简单来说就是消息的管家，
由他决定接收到的信息是放特定的队列，还是所有队列，还是直接丢弃。</p>

<p>其实在前两个实例里面，已经用到了exchange （channel.basic_publish(exchange=”,…），
这个exchange的名字为空，外号无名（人若无名，便可专心练剑~）。他会把你的消息都转达给routing_key指明的队列。
当我们声明了exchange以后，我们需要为queue和exchange建立联系，这时候，就要用到绑定（binding）了。
<code>
$ cd tut3
$ vim emitlog.py (代码如下)
$ vim recelog.py (代码如下)
</code>
日志生产者
&#8220;` python emitlog.py
#!/usr/bin/env python
import pika
import sys</p>

<p>connection = pika.BlockingConnection(pika.ConnectionParameters(
         host = ‘localhost’ ))
channel = connection.channel()</p>

<p>channel.exchange_declare(exchange = ‘logs’ ,
                          type = ‘fanout’ )</p>

<p>message = ‘ ‘ .join(sys.argv[ 1 :]) or “info: Hello World!”
channel.basic_publish(exchange = ‘logs’ ,
                       routing_key = ‘’,
                       body = message)
print “ [x] Sent %r” % (message,)
connection.close()
<code>
然后是日志消费者
</code> python recelog.py
#!/usr/bin/env python
import pika</p>

<p>connection = pika.BlockingConnection(pika.ConnectionParameters(
         host = ‘localhost’ ))
channel = connection.channel()
channel.exchange_declare(exchange = ‘logs’ ,
                          type = ‘fanout’ )
result = channel.queue_declare(exclusive = True )
queue_name = result.method.queue
channel.queue_bind(exchange = ‘logs’ ,
                    queue = queue_name)
print ‘ [*] Waiting for logs. To exit press CTRL+C’</p>

<p>def callback(ch, method, properties, body):
     print “ [x] %r” % (body,)</p>

<p>channel.basic_consume(callback,
                       queue = queue_name,
                       no_ack = True )
channel.start_consuming()
&#8220;`
测试：</p>

<p>和前一个实例差不多。开3个bash，2个跑recelog，1个跑emitlog。
查看recelog是否都收到emitlog发送的消息。代码里面用 了一个fanout(意思是成扇形展开)类型的exchange，
只要和exchange绑定的queue都能收到一份消息的 copy，routing_key会被忽略掉。</p>

<p><strong>5，路由模式 （选择接收信息）</strong>
<code>
$ cd tut4
$ vim emitlog.py (代码如下)
$ vim recelog.py (代码如下)
</code>
生产者
&#8220;` python emitlog.py
#!/usr/bin/env python
import pika
import sys</p>

<p>connection = pika.BlockingConnection(pika.ConnectionParameters(
         host = ‘localhost’ ))
channel = connection.channel()
channel.exchange_declare(exchange = ‘direct_logs’ ,
                          type = ‘direct’ )
severity = sys.argv[ 1 ] if len (sys.argv) &gt; 1 else ‘info’
message = ‘ ‘ .join(sys.argv[ 2 :]) or ‘Hello World!’
channel.basic_publish(exchange = ‘direct_logs’ ,
                       routing_key = severity,
                       body = message)
print “ [x] Sent %r:%r” % (severity, message)
connection.close()
&#8220;`
这里声明exchange时类型定义为direct（直接匹配），就是说只有当一个信息的routing_key和队列的binding_key一 致时，
信息才会被放入到这个队列。消息发布给exchange时必须带上routing_key。其实在消息生产端，队列这个概念是透明的。</p>

<p>消费者
&#8220;` python recelog.py
#!/usr/bin/env python
import pika
import sys</p>

<p>connection = pika.BlockingConnection(pika.ConnectionParameters(
         host = ‘localhost’ ))
channel = connection.channel()</p>

<p>channel.exchange_declare(exchange = ‘direct_logs’ ,
                          type = ‘direct’ )
result = channel.queue_declare(exclusive = True )
queue_name = result.method.queue
severities = sys.argv[ 1 :]
if not severities:
     print » sys.stderr, “Usage: %s [info] [warning] [error]” % \
                          (sys.argv[ 0 ],)
     sys.exit( 1 )
for severity in severities:
     channel.queue_bind(exchange = ‘direct_logs’ ,
                        queue = queue_name,
                        routing_key = severity)
print ‘ [*] Waiting for logs. To exit press CTRL+C’
def callback(ch, method, properties, body):
     print “ [x] %r:%r” % (method.routing_key, body,)
channel.basic_consume(callback,
                       queue = queue_name,
                       no_ack = True )
channel.start_consuming()
&#8220;`</p>

<p>这里首先定义exchange，和消息发送端是一样的。然后定义队列，队列是自动命名，
并且只要进程终止，队列就会终止。然后把队列和 exchange绑定，绑定时的routing_key是用户输入的，
如果输入多个key，就做多次的绑定。注意这里的队列还是一个。如果你需要建立两个 队列，就得跑两次这个python脚本。</p>

<p><strong>6，topic和rpc</strong></p>

<p>官方tutorial还有两个高级一点的实例，topic和rpc，这里就不作说明了，留着大家学学英文吧 :)</p>

<p>RabbitMQ提供了很多消息队列客户端代码，比如python，java，c等等，大家可以根据产品或项目的实际情况选择。关键是原理必须搞懂。</p>

<p><strong>其他资源：</strong></p>

<p>中文入门篇：<a href="http://adamlu.net/dev/2011/09/rabbitmq-get-started/">http://adamlu.net/dev/2011/09/rabbitmq-get-started/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CentOS6.4安装rabbitmq-server]]></title>
    <link href="http://yidao620c.github.io/blog/20150420/rabbitmq-server.html"/>
    <updated>2015-04-20T10:55:13+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150420/rabbitmq-server</id>
    <content type="html"><![CDATA[<h3 id="centos-64python">在 CentOS 6.4上安装python</h3>
<p>自己手动安装python2.7.5，不要动系统上面其他的版本</p>

<p><strong>1,先安装GCC，用如下命令yum install gcc gcc-c++</strong>
<code>
yum install zlib
yum install zlib-devel
</code>
<strong>2,下载 <a href="https://www.python.org/ftp/python/2.7.5/Python-2.7.5.tgz">python-2.7.5.tar.gz</a> 文件，修改文件权限</strong>
<code>
chmode +x python-7.5.tar.gz
</code>
<strong>3,解压tar文件</strong>
<code>
tar -xzvf python-2.7.5.tar.gz
</code>
<strong>4,编辑Setup.dist</strong>
<code>
cd python-2.7.5
vim Python-2.7.5/Modules/Setup.dist
</code>
找到<!--more--></p>

<pre><code>#SSL=/usr/local/ssl
#_ssl _ssl.c \
#       -DUSE_SSL -I$(SSL)/include -I$(SSL)/include/openssl \
#       -L$(SSL)/lib -lssl -lcrypto
......
#zlib zlibmodule.c -I$(prefix)/include -L$(exec_prefix)/lib -lz
</code></pre>

<p>把注释去掉后开始执行安装
<code>
./configure --prefix=/usr/local/python27 --with-zlib=/usr/include
make &amp;amp;&amp;amp; make install
</code>
<strong>5、建立软连接，使系统默认的python指向python27</strong>
<code>
mv /usr/bin/python /usr/bin/python2.6.6.old
ln -s /usr/local/python27/bin/python2.7 /usr/bin/python
</code>
已经安装完成python的安装或升级的全部操作了，我们再来看一下现在的python的版本：
<code>
python -V
Python 2.7.5
</code>
虽然现在python已经安装完成，但是使用yum命令会有问题——yum不能正常工作。</p>

<p>这是因为yum默认使用的python版本是2.6.6，到哪是现在的python版本是2.7.5，
故会出现上述问题，只需要该一下yum的默认python配置版本就行了：
<code>
vi /usr/bin/yum
</code>
将文件头部的<code>#!/usr/bin/python</code> 改为<code>#!/usr/bin/python2.6</code></p>

<h3 id="centos-64erlang">在 CentOS 6.4上安装Erlang</h3>
<p>在本节中，我们将来学习如何在CentOS 6.4上安装erlang，具体的Erlang版本是R16B02。</p>

<p>在安装之前，需要先要安装一些其他的软件，否则在安装中间会出现一些由于没有其依赖的软件模块而失败。</p>

<p><strong>1、首先要先安装GCC GCC-C++ Openssl等以来模块：</strong>
<code>
yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel
</code>
<strong>2、再安装ncurses模块</strong>
<code>
yum -y install ncurses-devel
yum install ncurses-devel
</code>
<strong>3、下载Erang源代码文件文件，并对其付权限和解压文件：</strong>
<code>
wget http://www.erlang.org/download/otp_src_R16B02.tar.gz
chmod +x otp_src_R16B02.tar.gz
tar -xzvf otp_src_R16B02.tar.gz
mv otp_src_R16B02 erlang_R16B #重命名解压厚的文件
</code>
<strong>4、下面是安装erlang的重头戏，依次执行以下操作：</strong>
<code>
cd erlang_R16B/
#不用java编译，故去掉java避免错误
./configure --prefix=/usr/local/erlang --with-ssl --enable-threads --enable-smp-support --enable-kernel-poll --enable-hipe --without-javac
make &amp;amp;&amp;amp; make install #编译后安装
</code>
<strong>5、配置erlang环境：</strong>
<code>
vi /etc/profile
ERL_HOME=/usr/local/erlang
export PATH=$PATH:$ERL_HOME/bin
</code>
好了，现在erlang的已经配置好了，现在我们来测试一下是否安装成功,在控制台输入命令erl，
如果在erlang shell里出现下图所示就说明安装成功了：
此处省略截图了…</p>

<h3 id="centosrabbitmq-server-315">在CentOS上安装rabbitmq-server-3.1.5</h3>
<p>在本节中我们来看一下如何在CentOS上安装RabbitMQ。
我们使用的rabbitmq的版本是rabbitmq-server-3.1.5.tar.gz，CentOS的版本是CentOS 6.4。</p>

<p>在安装rabbitmq之前需要先安装python和erlang，
这两部分的安装过程请参看在CentOS 6.4上安装python和在 CentOS 6.4上安装Erlang，这里不再赘述。</p>

<p>安装rabbitmq的具体步骤如下：</p>

<p><strong>1、下载rabbitmq-server-3.1.5.tar.gz文件，并解压之：</strong>
<code>
cd /usr/local
wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.1.5/rabbitmq-server-3.1.5.tar.gz
chmod +x rabbitmq-server-3.1.5.tar.gz
tar -xzvf rabbitmq-server-3.1.5.tar.gz
</code>
<strong>2、在编译rabbitmq源码之前先要安装其需要依赖包：</strong>
<code>
yum -y install xmlto
</code>
否则会编译不通过：
<code>
/bin/sh: line 1: xmlto: command not found
</code>
<strong>3、开始编译源代码：</strong>
<code>
cd rabbitmq-server-3.1.5
make
#将rabbitmq编译到/opt/mq/rabbitmq目录
make install TARGET_DIR=/opt/mq/rabbitmq SBIN_DIR=/opt/mq/rabbitmq/sbin MAN_DIR=/opt/mq/rabbitmq/man
</code>
<strong>4、安装web插件管理界面</strong>
<code>
cd /opt/mq/rabbitmq/sbin
mkdir /etc/rabbitmq/
rabbitmq-plugins enable rabbitmq_management
</code>
<strong>5、好了，到这里rabbitmq已经配置好了，可以启动了：</strong>
<code>
./rabbitmq-server start &amp;
</code>
我运行的时候报错了，ERROR: epmd error for host “springzoo”: timeout (timed out)</p>

<p>更改下/etc/hosts:</p>

<pre><code>127.0.0.1   localhost springzoo
::1         localhost springzoo
</code></pre>

<p>接下来我们查看下端口
<code>
ps aux | grep rabbitmq #查看端口，默认就是5672
netstat -tnlp | grep 5672
</code>
应该是下面的结果</p>

<pre><code>tcp        0      0 0.0.0.0:15672               0.0.0.0:*                   LISTEN      30435/beam.smp
tcp        0      0 0.0.0.0:55672               0.0.0.0:*                   LISTEN      30435/beam.smp
tcp        0      0 :::5672                     :::*                        LISTEN      30435/beam.smp
</code></pre>

<p>如果看到下面的信息就表明已经启动成功了！
省略截图….</p>

<p>最好我们就可以在浏览器上输入http://127.0.0.1:15672/登录管理界面了</p>

<p>使用登录的名户名和密码默认都算guest，登录后的页面如下：</p>

<p>截图再次省略…</p>

]]></content>
  </entry>
  
</feed>
