<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类目录：simpleblog | 笨跑的一刀]]></title>
  <link href="http://yidao620c.github.io/blog/categories/simpleblog/atom.xml" rel="self"/>
  <link href="http://yidao620c.github.io/"/>
  <updated>2015-05-17T20:07:25+08:00</updated>
  <id>http://yidao620c.github.io/</id>
  <author>
    <name><![CDATA[熊能]]></name>
    <email><![CDATA[yidao620@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Django1.7开发博客（14）- 集成Xadmin]]></title>
    <link href="http://yidao620c.github.io/blog/20150421/simpleblog-14.html"/>
    <updated>2015-04-21T21:45:29+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150421/simpleblog-14</id>
    <content type="html"><![CDATA[<h3 id="xadmin">Xadmin介绍</h3>
<p>xadmin是一个django的管理后台实现，使用了更加灵活的架构设计及Bootstrap UI框架，
目的是替换现有的admin，国人开发，有许多新的特性：</p>

<ul>
  <li>兼容 Django Admin</li>
  <li>使用 Bootstrap 作为 UI 框架</li>
  <li>编辑页面灵活布局</li>
  <li>主页面仪表盘及小部件</li>
  <li>过滤器强化</li>
  <li>数据导出</li>
  <li>强大的插件机制</li>
</ul>

<p>项目主页：<a href="http://sshwsfc.github.io/django-xadmin/">http://sshwsfc.github.io/django-xadmin/</a></p>

<p>在线demo: <a href="http://demo.xadmin.io/">http://demo.xadmin.io/</a></p>

<h3 id="django">与django的集成</h3>

<p>本篇以simpleblog项目为例，介绍下怎样在django中集成xadmin<!--more--></p>

<h4 id="python27">python2.7环境切换</h4>

<p>注意，前面的教程都是在python3.4环境下开放的。
而目前为止xadmin还只能支持python2，所以我们要在此项目基础上新建一个分支py27，
然后我们创建一个python2.7的virtual environment，切换到此环境下面即可。</p>

<h4 id="section">添加依赖</h4>

<p>在requirements.txt中添加如下的依赖，注意：要用到xadmin的django1.7分支</p>

<pre><code>django-reversion==1.8.5
xlwt==0.7.5
git+https://github.com/sshwsfc/django-xadmin.git@django1.7
</code></pre>

<h4 id="settingspy">修改settings.py</h4>

<p>增加xadmin的配置如下
&#8220;` python
ADMINS = (
    # (‘Your Name’, ‘your_email@example.com’),
)
MANAGERS = ADMINS</p>

<h1 id="application-definition">Application definition</h1>
<p>INSTALLED_APPS = (
    # …
    ‘xadmin’,
    ‘crispy_forms’,
    ‘reversion’,
    # …
)
&#8220;`</p>

<h4 id="xadmin-1">添加/xadmin的链接</h4>

<p>修改<code>mysite/urls.py</code>如下</p>

<p>{% raw %}</p>

<p>&#8220;` python
#!/usr/bin/env python
# -<em>- encoding: utf-8 -</em>-
from django.conf.urls import patterns, include, url
# version模块自动注册需要版本控制的 Model
from xadmin.plugins import xversion
xversion.register_models()</p>

<p>urlpatterns = patterns(
    ‘’,
    url(r’xadmin/’, include(xadmin.site.urls), name=’xadmin’),
    # …
)
&#8220;`
{% endraw %}</p>

<h4 id="adminxpy">创建adminx.py</h4>

<p>在blog/目录下创建adminx.py，内容如下</p>

<p>{% raw %}</p>

<p>&#8220;` python
#!/usr/bin/env python
# -<em>- encoding: utf-8 -</em>-
“””
Topic: adminx定制类
Desc :
“””
import xadmin
import xadmin.views as xviews
from .models import Tag, Category, Post, Comment, Evaluate, Page
from xadmin.layout import Main, TabHolder, Tab, Fieldset, Row, Col, AppendedText, Side</p>

<p>class BaseSetting(object):
    enable_themes = True
    use_bootswatch = True
xadmin.site.register(xviews.BaseAdminView, BaseSetting)</p>

<p>class AdminSettings(object):
    # 设置base_site.html的Title
    site_title = ‘博客管理后台’
    # 设置base_site.html的Footer
    site_footer = ‘Winhong Inc.’
    menu_style = ‘default’</p>

<pre><code># 菜单设置
def get_site_menu(self):
    return (
        {'title': '博客管理', 'perm': self.get_model_perm(Page, 'change'), 'menus': (
            {'title': '所有页面', 'icon': 'fa fa-vimeo-square'
                , 'url': self.get_model_url(Page, 'changelist')},
            {'title': '分类目录', 'icon': 'fa fa-vimeo-square'
                , 'url': self.get_model_url(Category, 'changelist')},
        )},
    ) xadmin.site.register(xviews.CommAdminView, AdminSettings)
</code></pre>

<p>xadmin.site.register(Page)
xadmin.site.register(Category)
# xadmin.site.register(Tag)
# xadmin.site.register(Post)
# xadmin.site.register(Comment)
# xadmin.site.register(Evaluate)
&#8220;`
{% endraw %}</p>

<p>在这里，我们将所有的model都注册到xadmin中去，这样后台就能自动管理它们了。
并且自定义了后台的一些菜单、标题等等。具体的定制方法可以参考xadmin的官方文档。</p>

<h4 id="section-1">添加管理后台链接</h4>

<p>在<code>mysite/templates/mysite/base.html</code>模板中添加/xamdin的管理后台链接：</p>

<p>{% raw %}</p>

<p>&#8220;`</p>
<div id="meta-2" class="widget widget_meta">
    <h3>功能</h3>
    <ul>
        {% if user.is_superuser %}
        <li><a href="http://yidao620c.github.io/xadmin">管理站点</a></li>
        {% endif %}
        {% if user.is_authenticated %}
        <li>
            <a href="{% url 'django.contrib.auth.views.logout' %}">登出</a>
        </li>
        {% else %}
        <li>
            <a href="{% url 'django.contrib.auth.views.login' %}">登录</a>
        </li>
        {% endif %}
        <li><a href="#">文章<abbr title="RSS">RSS</abbr></a></li>
    </ul>
</div>
<p>&#8220;`
{% endraw %}</p>

<h4 id="section-2">自定义后台登陆页面</h4>

<p>新建<code>mysite/templates/registration/login.html</code>模板，将xadmin模块中的login.html复制过来，
修改其内容，改成自己想要的形式即可</p>

<p>{% raw %}</p>

<p>&#8220;` html
{% load staticfiles %}
{% load i18n %}</p>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="" />
    <meta name="robots" content="NONE,NOARCHIVE" />
    <title>用户登录 - SimpleBlog</title>
    <!--...中间省略...-->
    <script type="text/javascript" src="{% static 'xadmin/vendor/jquery/jquery.js' %}"></script>
</head>
<body class="login">
<div class="container">
    <form method="post" action="{% url 'django.contrib.auth.views.login' %}">
        {% csrf_token %}
        <div class="panel panel-default panel-single" id="panel-login">
            <div class="panel-heading">
                <h2 class="form-signin-heading">请登录</h2>
            </div>
            <!--...中间省略...-->
        </div>
    </form>

</div>
<!--...中间省略...-->
<script type="text/javascript" src="{% static 'xadmin/js/xadmin.main.js' %}"></script>
<script type="text/javascript" src="{% static 'xadmin/js/xadmin.responsive.js' %}"></script>
<script type="text/javascript" src="{% static 'xadmin/vendor/jquery-ui/jquery.ui.effect.js' %}"></script>
<script type="text/javascript" src="{% static 'xadmin/js/xadmin.plugin.themes.js' %}"></script>

</body>
</html>
<p>&#8220;`
{% endraw %}</p>

<p>这些完成后，我们打开应用，访问<code>管理站点</code>链接，应该可以看到如下的登录页面</p>

<p><img src="http://yidaospace.qiniudn.com/dj110.png" alt="" /></p>

<p>登录后的效果</p>

<p><img src="http://yidaospace.qiniudn.com/dj111.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django1.7开发博客（13）- redis缓存]]></title>
    <link href="http://yidao620c.github.io/blog/20150421/simpleblog-13.html"/>
    <updated>2015-04-21T20:27:29+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150421/simpleblog-13</id>
    <content type="html"><![CDATA[<h3 id="wiki">Wiki</h3>
<p>Redis 是一个高性能的key-value数据库。redis的出现，
很大程度补偿了memcached这类keyvalue存储的不足，在部分场合可以对关系数据库起到很好的补充作用。
它提供了Python，Ruby，Erlang，PHP客户端，使用很方便。</p>

<p>目前Redis已经发布了3.0版本，正式支持分布式，这个特性太强大，以至于你再不用就对不住自己了。</p>

<h3 id="section">性能测试</h3>
<p>服务器配置：Linux 2.6, Xeon X3320 2.5Ghz</p>

<p>SET操作每秒钟110000次，GET操作每秒钟81000次</p>

<p>stackoverflow网站使用Redis做为缓存服务器。</p>

<h3 id="redis">安装redis</h3>
<p>服务器安装篇我写了专门文章，
请参阅<a href="http://yidao620c.github.io/blog/20150418/redis-install.html">redis入门与安装</a></p>

<h3 id="django">django中的配置</h3>
<p>我们希望在本博客系统中，对于文章点击数、阅览数等数据实现缓存，提高效率。<!--more--></p>

<h4 id="requirementstxt">requirements.txt</h4>
<p>添加如下内容，方便部署到heroku上面</p>

<pre><code>redis==2.10.3
django-redis==3.7.2
APScheduler==3.0.1
</code></pre>

<h4 id="settingspy">settings.py配置</h4>
<p>新增内容
&#8220;` python
from urllib.parse import urlparse
import dj_database_url</p>

<p>redis_url = urlparse(os.environ.get(‘REDISTOGO_URL’, ‘redis://localhost:6959’))
CACHES = {
    ‘default’: {
        ‘BACKEND’: ‘redis_cache.cache.RedisCache’,
        ‘LOCATION’: ‘{0}:{1}’.format(redis_url.hostname, redis_url.port),
        ‘OPTIONS’: {
            ‘DB’: 0,
            ‘PASSWORD’: redis_url.password,
            ‘CLIENT_CLASS’: ‘redis_cache.client.DefaultClient’,
            ‘PICKLE_VERSION’: -1,  # Use the latest protocol version
            ‘SOCKET_TIMEOUT’: 60,  # in seconds
            ‘IGNORE_EXCEPTIONS’: True,
        }
    }
}</p>

<p>SESSION_ENGINE = ‘django.contrib.sessions.backends.cache’
SESSION_CACHE_ALIAS = ‘default’</p>

<h1 id="localsettingspy">本地开发配置放在local_settings.py中</h1>
<p>try:
    from .local_settings import *
except ImportError:
    pass
&#8220;`</p>

<h4 id="localsettingspy-1">local_settings.py配置</h4>
<p>这个是本地开发时候使用到的配置文件
&#8220;` python
DEBUG = True</p>

<p>CACHES = {
    ‘default’: {
        ‘BACKEND’: ‘redis_cache.cache.RedisCache’,
        ‘LOCATION’: ‘192.168.203.95:6379:1’,
        ‘OPTIONS’: {
            ‘CLIENT_CLASS’: ‘redis_cache.client.DefaultClient’,
            # ‘PASSWORD’: ‘secretpassword’,
            ‘PICKLE_VERSION’: -1,  # Use the latest protocol version
            ‘SOCKET_TIMEOUT’: 60,  # in seconds
            ‘IGNORE_EXCEPTIONS’: True,
        }
    }
}
&#8220;`</p>

<h3 id="section-1">使用方法</h3>

<h4 id="cachemanagerpy">cache_manager.py缓存管理器</h4>
<p>我们新建一个缓存管理器cache_manager.py，内容如下
&#8220;` python
#!/usr/bin/env python
# -<em>- encoding: utf-8 -</em>-
“””
Topic: redis缓存管理器
“””
from ..models import Post
from redis_cache import get_redis_connection
from apscheduler.schedulers.background import BackgroundScheduler</p>

<p>RUNNING_TIMER = False
REDIS_DB = get_redis_connection(‘default’)</p>

<p>def update_click(post):
    “”” 更新点击数 “””
    if REDIS_DB.hexists(“CLICKS”, post.id):
        print(‘REDIS_DB.hexists…’ + str(post.id))
        REDIS_DB.hincrby(‘CLICKS’, post.id)
    else:
        print(‘REDIS_DB.not_hexists…’ + str(post.id))
        REDIS_DB.hset(‘CLICKS’, post.id, post.click + 1)
    run_timer()</p>

<p>def get_click(post):
    “”” 获取点击数 “””
    if REDIS_DB.hexists(“CLICKS”, post.id):
        return REDIS_DB.hget(‘CLICKS’, post.id)
    else:
        REDIS_DB.hset(‘CLICKS’, post.id, post.click)
        return post.click</p>

<p>def sync_click():
    “&#8221;”同步文章点击数”””
    print(‘同步文章点击数start….’)
    for k in REDIS_DB.hkeys(‘CLICKS’):
        try:
            p = Post.objects.get(k)
            print(‘db_click={0}’.format(p.click))
            cache_click = get_click(p.id)
            print(‘cache_click={0}’.format(cache_click))
            if cache_click != p.click:
                p.click = get_click(p.id)
                p.save()
        except:
            pass
&#8220;`</p>

<h4 id="viewspy">views.py修改</h4>
<p>然后我们修改view.py，在相应的action里使用这个cache_manager：
&#8220;` python
from .commons import cache_manager</p>

<p>def post_list(request):
    “&#8221;”所有已发布文章”””
    posts = Post.objects.annotate(num_comment=Count(‘comment’)).filter(
        published_date__isnull=False).prefetch_related(
        ‘category’).prefetch_related(‘tags’).order_by(‘-published_date’)
    for p in posts:
        p.click = cache_manager.get_click(p)
    return render(request, ‘blog/post_list.html’, {‘posts’: posts})</p>

<p>def post_detail(request, pk):
    try:
        pass
    except:
        raise Http404()
    if post.published_date:
        cache_manager.update_click(post)
        post.click = cache_manager.get_click(post)
&#8220;`
其他的我就不多演示了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django1.7开发博客（12）- i18n国际化]]></title>
    <link href="http://yidao620c.github.io/blog/20150421/simpleblog-12.html"/>
    <updated>2015-04-21T19:27:29+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150421/simpleblog-12</id>
    <content type="html"><![CDATA[<h3 id="wiki">Wiki</h3>
<p>国际化与本地化的目的为了能为各个不同的用户以他们最熟悉的语言和格式来显示网页。</p>

<p>Django能完美支持文本翻译、日期时间和数字的格式化、时区。</p>

<p>另外，Django还有两点优势：</p>

<ol>
  <li>允许开发者和模板作者指定他们哪些app应该被翻译或被格式化为本地形式。</li>
  <li>允许用户根据自己的偏好来实现本地化显示。翻译依据语言，格式化依据国家，
这些信息由浏览器中的<code>Accept-Language</code>头来决定。不过目前为止时区还未能实现。</li>
</ol>

<p>参考官方文档：<a href="https://docs.djangoproject.com/en/1.7/topics/i18n/">https://docs.djangoproject.com/en/1.7/topics/i18n/</a></p>

<h3 id="section">配置</h3>
<p>实际上django的国际化做的非常好了，配置很简单。</p>

<h4 id="settingspy">settings.py</h4>
<p>首先在settings中，添加如下内容：<!--more-->
<code>python
from django.utils.translation import ugettext_lazy as _
LANGUAGES = (
    ('zh-cn', _('Simplified Chinese')),
    ('en', _('English')),
)
LOCALE_PATHS = (
    os.path.join(BASE_DIR, "locale"),
)
</code>
通过<code>LANGUAGES</code>执行语言列表，<code>LOCALE_PATHS</code>指定国际化目录。</p>

<p>在项目根目录下面创建一个locale文件夹，然后使用命令创建国际化文件：
<code>
django-admin.py makemessages -l zh_CN
</code></p>

<p>执行完后，locale文件夹下面创建<code>zh_CN/LC_MESSAGES/django.po</code>，里面的内容类似下面：</p>

<p>&#8220;` python
# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE’S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR.
#
#, fuzzy
msgid “”
msgstr “”
“Project-Id-Version: PACKAGE VERSION\n”
“Report-Msgid-Bugs-To: \n”
“POT-Creation-Date: 2014-11-26 11:45+0800\n”
“PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n”
“Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n”
“Language-Team: LANGUAGE <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#076;&#076;&#064;&#108;&#105;&#046;&#111;&#114;&#103;">&#076;&#076;&#064;&#108;&#105;&#046;&#111;&#114;&#103;</a>\n”
“MIME-Version: 1.0\n”
“Content-Type: text/plain; charset=UTF-8\n”
“Content-Transfer-Encoding: 8bit\n”
“Plural-Forms: nplurals=1; plural=0;\n”</p>

<h1 id="mysitesettingspy94">: .\mysite\settings.py:94</h1>
<p>msgid “Simplified Chinese”
msgstr “简体中文”</p>

<h1 id="mysitesettingspy95">: .\mysite\settings.py:95</h1>
<p>msgid “English”
msgstr “English”</p>

<h1 id="basehtml">: base.html</h1>
<p>msgid “Simple Blog”
msgstr “极简博客”</p>

<p>msgid “Hello”
msgstr “欢迎你”</p>

<p>msgid “previous”
msgstr “上一页”</p>

<p>msgid “next”
msgstr “下一页”</p>

<p>&#8220;`
将你页面上面需要翻译的内容写到这里面来即可。比如<code>previous</code>要翻译成<code>上一页</code>。</p>

<p>写好了所有的翻译后，再执行：
<code>
django-admin.py compilemessages
</code>
这时候会生成文件<code>zh_CN/LC_MESSAGES/django.mo</code>，这个是最终的目标文件了。</p>

<h3 id="section-1">使用</h3>
<p>我们用<code>base.html</code>来做演示，打开<code>mysite/templates/mysite/base.html</code></p>

<p>{% raw %}</p>

<p>&#8220;` html
{% load staticfiles %}
{% load i18n %}</p>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <title>{% trans &#8216;Simple Blog&#8217;%}</title>
</head>
<body class="customize-support">
<div class="page-header">
    {% if user.is_authenticated %}
        <a href="{% url 'post_new' %}" class="top-menu"><span class="glyphicon glyphicon-plus"></span></a>
        <a href="{% url 'post_draft_list' %}" class="top-menu"><span class="glyphicon glyphicon-edit"></span></a>
        <p class="top-menu" style="font-size: 15pt;">{% trans &#8216;Hello&#8217;%} {{ user.username }}
            <small>&nbsp;</small>
            <a href="{% url 'django.contrib.auth.views.logout' %}" class="top-menu">
                <span class="glyphicon glyphicon-log-out"></span></a>
        </p>
    {% else %}
        <a href="{% url 'django.contrib.auth.views.login' %}" class="top-menu">
            <span class="glyphicon glyphicon-log-in"></span></a>
    {% endif %}
    <h1><a href="{% url 'blog.views.post_list' %}">{% trans &#8216;Simple Blog&#8217;%}</a></h1>
</div>
&#8230;
</body>
</html>
<p>&#8220;`
{% endraw %}</p>

<p>注意{% raw %}<code>&lt;title&gt;{% trans 'Simple Blog'%}&lt;/title&gt;</code>{% endraw %}这句，
如果用户选择中文，那么就会被翻译成<code>极简博客</code>。
这个在django.po文件中定义过。其他的内容也是类似，就不多说了。</p>

<p>好了，i18n国际化就是这么简单。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django1.7开发博客（11）- 富文本与代码高亮]]></title>
    <link href="http://yidao620c.github.io/blog/20150421/simpleblog-11.html"/>
    <updated>2015-04-21T18:27:29+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150421/simpleblog-11</id>
    <content type="html"><![CDATA[<h2 id="tinymce">TinyMCE介绍</h2>
<p>TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，支持目前流行的各种浏览器，由JavaScript写成。
功能配置灵活简单（两行代码就可以将编辑器嵌入网页中），支持AJAX。另一特点是加载速度非常快。</p>

<p>django里引用TinyMCE富文本编辑器，其实很简单，前提是你知道django的静态文件配置。
其实这个我已经在前面文章提到过，可以回去再看看。</p>

<p>TinyMCE的官方网站是：<a href="http://www.tinymce.com/">http://www.tinymce.com/</a></p>

<p>下载地址：<a href="http://download.moxiecode.com/tinymce/tinymce_4.1.9.zip">http://download.moxiecode.com/tinymce/tinymce_4.1.9.zip</a></p>

<p>TinyMCE的最新版本是4.1.9，下面是官网截屏：</p>

<p><img src="http://yidaospace.qiniudn.com/tinymce.png" alt="" /></p>

<p>下载下来后，我们把它解压到工程的static/目录下面，如下图所示：<!--more--></p>

<p><img src="http://yidaospace.qiniudn.com/dj101.png" alt="" /></p>

<h2 id="section">安装原理</h2>
<p>安装的原理很简单，只需要在使用编辑器的页面里引用tinymce.min.js文件并初始化就可以了。
tinymce.min.js文件在tinymce项目里，
tinymce.min.js会根据初始配置里的信息找到需要用编辑器的html节点。</p>

<p>例如在post_edit.html页面使用编辑器，只需要在模板文件写下：</p>

<p>{% raw %}</p>

<p><code>html
{% load staticfiles %}
{% block header %}
    &lt;link rel="stylesheet" href="{% static 'tinymce/plugins/upload/plugin.css' %}"&gt;
    &lt;script type="text/javascript" src="{% static 'tinymce/tinymce.min.js' %}"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
        tinymce.init({
            selector: "textarea",
            //width: 800,
            height: 300,
            forced_root_block: false,
            plugins: [
                "advlist autolink lists link image charmap print preview anchor sh4tinymce upload",
                "searchreplace visualblocks code fullscreen",
                "insertdatetime table contextmenu paste"
            ],
            toolbar: "insertfile undo redo | styleselect | bold italic | alignleft aligncenter" +
            " alignright alignjustify | bullist numlist outdent indent | preview link image sh4tinymce"
        });
    &lt;/script&gt;
{% endblock %}
</code>
{% endraw %}</p>

<p>这段代码的含义是 初始化 tinyMCE编辑器，selector指需要将编辑器显示在html那个标签节点，
这里选了textareas。则表示<textareas>会变成编辑器所在的位置。</textareas></p>

<p>另外，我还自定义一下编辑器的高度、插件、菜单项目等。具体详细配置请参考官方文档，写的都比较清楚。</p>

<h2 id="tinymceaddmore">给TinyMCE增加一个addmore插件</h2>
<p>需求很简单，就是每次我写文章的时候需要插入某个<code>&lt;!--more--&gt;</code>标签，
这样可以在列表页面先只显示文章的一部分，然后碰到这个more标签就显示一个”点击阅读更多”的链接。</p>

<p>第一步，在tinymce/plugins文件下新增一个addmore文件夹，然后在里面新建一个plugin.min.js文件，
内容如下：</p>

<p><code>
tinymce.PluginManager.add("addmore", function (a) {
    a.addCommand("InsertMoreRule", function () {
        a.execCommand("mceInsertContent", !1, "[!--more--]")
    }), a.addButton("addmore", {
        icon: "addmore",
        tooltip: "Insert More",
        cmd: "InsertMoreRule"
    }), a.addMenuItem("addmore", {
        icon: "addmore",
        text: "Insert More",
        cmd: "InsertMoreRule",
        context: "insert"
    })
});
</code></p>

<p>在post_edit.html中修改tinymce.init方法，plugins项目后面添加一个addmore：</p>

<pre><code>...
plugins: [
    "advlist autolink lists link image charmap print preview anchor sh4tinymce upload",
    "searchreplace visualblocks code fullscreen",
    "insertdatetime table contextmenu paste addmore"
],
...
</code></pre>

<p>再看看效果，没问题了。</p>

<h2 id="syntaxhighlighter">SyntaxHighlighter代码高亮</h2>
<p>程序员写博客当然少不了代码高亮，这个功能页很容易实现。有一款插件叫SyntaxHighlighter值的推荐。</p>

<p>项目主页：<a href="http://alexgorbatchev.com/SyntaxHighlighter/">http://alexgorbatchev.com/SyntaxHighlighter/</a></p>

<p>下载地址：<a href="http://alexgorbatchev.com/SyntaxHighlighter/download/download.php?sh_current">http://alexgorbatchev.com/SyntaxHighlighter/download/download.php?sh_current</a></p>

<p>下载下来后直接解压到static/目录下面，这个跟tinymce是一样的原理。</p>

<p><strong>使用方法</strong></p>

<p>只需要修改django页面的基础模板就行了，非常简单。</p>

<p>打开mysite/templates/mysite/base.html页面，引入syntaxhighlighter：
{% raw %}</p>

<p>&#8220;` html
{% load staticfiles %}
{% load i18n %}</p>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="{% static 'css/bootstrap.min.css' %}" />
    <!-- Optional theme -->
    <link rel="stylesheet" href="{% static 'css/bootstrap-theme.min.css' %}" />
    <!-- Blog CSS-->
    <link rel="stylesheet" href="{% static 'css/blog.css' %}" />
    <link type="text/css" rel="stylesheet" href="{% static 'syntaxhighlighter/styles/shCoreDefault.css' %}" />
    <script type="text/javascript" src="{% static 'syntaxhighlighter/scripts/shCore.js' %}"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="{% static 'js/jquery-1.11.1.min.js' %}"></script>
    <script src="{% static 'js/base.js' %}"></script>
    <script src="{% static 'js/bootstrap.min.js' %}"></script>
    {% block header %}
    {% endblock %}
    <title>{% trans &#8216;Simple Blog&#8217;%}</title>
</head>
<body class="customize-support">
中间省略&#8230;
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushJScript.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushBash.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushPhp.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushJava.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushSql.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushXml.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushPython.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushCss.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushCpp.js' %}"></script>
</body>
</html>
<p>&#8220;`
{% endraw %}</p>

<p>由于我们之前已经安装过了TinyMCE，这个跟它结合起来就非常好用了，因为TinyMCE自带有选择代码语言功能。</p>

<p>下面是我创建文章时，插入了一段python代码的示例：</p>

<p><img src="http://yidaospace.qiniudn.com/dj102.png" alt="" /></p>

<p>这个是保存后的效果：</p>

<p><img src="http://yidaospace.qiniudn.com/dj103.png" alt="" /></p>

<h2 id="section-1">最后一件事</h2>
<p>别忘了部署到Heroku上面和别人分享你的成果。</p>

<p>OK，到此为止，前台的各种功能已经差不多了，你能一直坚持学到这里很不错了，为你自己鼓掌吧。</p>

<p>后面还有一个重头戏，就是django的后台管理，我选择了更美观更好用的xamdin，敬请期待…</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django1.7开发博客（10）- 全文搜索]]></title>
    <link href="http://yidao620c.github.io/blog/20150421/simpleblog-10.html"/>
    <updated>2015-04-21T15:47:28+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150421/simpleblog-10</id>
    <content type="html"><![CDATA[<h3 id="wiki">Wiki：</h3>
<p>Django本身不提供全文检索的功能，但django-haystack为其提供了全文检索的框架。
django-haystack能为Django提供whoosh,solr,Xapian和Elasticsearc四种全文检索引擎作为后端。
其中whoosh为纯python的实现，不是非常大型的应用，是没有问题的。
本文将介绍Django1.7中通过django-haystack与whoosh集成以及whoosh的中文支持。</p>

<h3 id="section">安装依赖：</h3>
<p><code>
pip install django-haystack
pip install whoosh
pip install jieba
</code></p>

<h3 id="section-1">建立模型</h3>
<p>我们以文章为搜索目标，现在我的app名字为blog，
模型文件是mysite/blog/models.py ：<!--more--></p>

<p>&#8220;` python
# coding=utf-8
from django.db import models
@python_2_unicode_compatible
class Post(models.Model):
    class Meta:
        verbose_name = u’文章’
        verbose_name_plural = u’文章’
    # 作者
    author = models.ForeignKey(User)
    # 标题
    title = models.CharField(max_length=200)
    # 正文
    text = models.TextField()
    # 标签
    tags = models.ManyToManyField(Tag)
    # 分类目录
    category = models.ForeignKey(Category)
    # 点击量
    click = models.IntegerField(default=0)
    # 创建时间
    created_date = models.DateTimeField(default=timezone.now)
    # 发布时间
    published_date = models.DateTimeField(blank=True, null=True)</p>

<pre><code>def publish(self):
    self.published_date = timezone.now()
    self.save()

def __str__(self):
    return self.title ```
</code></pre>

<h3 id="searchindexespy">1. search_indexes.py</h3>
<p>在app目录下建立一个search_indexes.py（mysite/blog/search_indexes.py）代码如下：</p>

<p>&#8220;` python
#!/usr/bin/env python
# -<em>- encoding: utf-8 -</em>-
from models import Post
from haystack import indexes
class PostIndex(indexes.SearchIndex, indexes.Indexable):
    text = indexes.CharField(document=True, use_template=True)
    # 对title字段进行索引
    title = indexes.CharField(model_attr=’title’)
    def get_model(self):
        return Post</p>

<pre><code>def index_queryset(self, using=None):
    return self.get_model().objects.all() ```
</code></pre>

<p><em>备注</em>：search_indexes.py文件名不能修改，否则报错：<code>No fields were found in any search_indexes.</code></p>

<h3 id="posttexttxt">2. post_text.txt</h3>
<p>因为在search_indexes.py使用了use_template=True，所以可以同时使用模板对索引字段进行定义。</p>

<p>如：<code>mysite/blog/templates/search/indexes/blog/post_text.txt</code>:</p>

<p><code>
{{ object.title }}
{{ object.text }}
</code></p>

<h3 id="settingspy">3. settings.py</h3>

<p><code>python
# Application definition
INSTALLED_APPS = (
    ...
    'haystack',
)
</code></p>

<h3 id="urlspy">4. urls.py</h3>

<p><code>python
urlpatterns = patterns(
    '',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^xadmin/', include(xadmin.site.urls), name='xadmin'),
    url(r'^accounts/login/$', 'django.contrib.auth.views.login'),
    url(r'^accounts/logout/$', 'django.contrib.auth.views.logout', {'next_page': '/'}),
    url(r'^search/', include('haystack.urls')),
    url(r'', include('blog.urls')),
)
</code></p>

<h3 id="jieba">5. jieba中文分词</h3>
<p>jieba其实已经提供了集成whoosh的ChineseAnalyzer，
也就是说不需要自己写ChineseAnalyzer了，直接在whoosh_backend.py中直接引用就好；
同时，不推荐将whoosh_backend.py放到Lib下面，这样移植性会有问题，自己的代码，还是放在项目下面为妙。</p>

<p>1. 将文件whoosh_backend.py拷贝到app下面，并重命名为whoosh_cn_backend.py，
如blog/whoosh_cn_backend.py。重点的改造有：</p>

<ul>
  <li>增加：
<code>python
from jieba.analyse import ChineseAnalyzer
</code></li>
  <li>修改
<code>python
schema_fields[field_class.index_fieldname] = TEXT(stored=True, analyzer=ChineseAnalyzer(),
 field_boost=field_class.boost, sortable=True)
</code>
2. 修改后端引擎，setting.py配置：</li>
</ul>

<p><code>python
# full text search
HAYSTACK_CONNECTIONS = {
    'default': {
        'ENGINE': 'blog.whoosh_cn_backend.WhooshEngine',
        'PATH': os.path.join(BASE_DIR, 'whoosh_index'),
    },
}
</code></p>

<h3 id="section-2">6. 重建索引</h3>

<p><code>python
python manage.py rebuild_index
</code></p>

<h3 id="section-3">7. 索引更新</h3>

<p>最简单的办法就是在settings.py中添加：
<code>python
HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'
</code></p>

<h3 id="section-4">8. 自定义搜索示例</h3>

<p>(1) 先定义view：</p>

<p><code>python
from haystack.forms import SearchForm
def full_search(request):
    """全局搜索"""
    keywords = request.GET['q']
    sform = SearchForm(request.GET)
    posts = sform.search()
    return render(request, 'blog/post_search_list.html',
                  {'posts': posts, 'list_header': '关键字 \'{}\' 搜索结果'.format(keywords)})
</code></p>

<p>(2) 然后在template页面中：
{% raw %}</p>

<p>&#8220;` html
<!-- searchbox START --></p>
<div id="searchbox">
    <form action="{% url 'blog.views.full_search' %}" method="get">
        <div class="content">
            <label>
                <input type="text" class="textfield searchtip" name="q" size="24" value="" />
            </label>
            <input type="submit" class="button" value="" />
        </div>
    </form>
</div>
<p>&#8220;`
{% endraw %}</p>

<p>更详细内容请参考官方文档：<a href="http://django-haystack.readthedocs.org/en/latest/">http://django-haystack.readthedocs.org/en/latest/</a></p>
]]></content>
  </entry>
  
</feed>
