<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类目录：django | 笨跑的一刀]]></title>
  <link href="http://yidao620c.github.io/blog/categories/django/atom.xml" rel="self"/>
  <link href="http://yidao620c.github.io/"/>
  <updated>2015-04-27T12:09:18+08:00</updated>
  <id>http://yidao620c.github.io/</id>
  <author>
    <name><![CDATA[熊能]]></name>
    <email><![CDATA[yidao620@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Django1.7开发博客（13）- redis缓存]]></title>
    <link href="http://yidao620c.github.io/blog/20150421/simpleblog-13.html"/>
    <updated>2015-04-21T20:27:29+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150421/simpleblog-13</id>
    <content type="html"><![CDATA[<h3 id="wiki">Wiki</h3>
<p>Redis 是一个高性能的key-value数据库。redis的出现，
很大程度补偿了memcached这类keyvalue存储的不足，在部分场合可以对关系数据库起到很好的补充作用。
它提供了Python，Ruby，Erlang，PHP客户端，使用很方便。</p>

<p>目前Redis已经发布了3.0版本，正式支持分布式，这个特性太强大，以至于你再不用就对不住自己了。</p>

<h3 id="section">性能测试</h3>
<p>服务器配置：Linux 2.6, Xeon X3320 2.5Ghz</p>

<p>SET操作每秒钟110000次，GET操作每秒钟81000次</p>

<p>stackoverflow网站使用Redis做为缓存服务器。</p>

<h3 id="redis">安装redis</h3>
<p>服务器安装篇我写了专门文章，
请参阅<a href="http://yidao620c.github.io/blog/20150418/redis-install.html">redis入门与安装</a></p>

<h3 id="django">django中的配置</h3>
<p>我们希望在本博客系统中，对于文章点击数、阅览数等数据实现缓存，提高效率。<!--more--></p>

<h4 id="requirementstxt">requirements.txt</h4>
<p>添加如下内容，方便部署到heroku上面</p>

<pre><code>redis==2.10.3
django-redis==3.7.2
APScheduler==3.0.1
</code></pre>

<h4 id="settingspy">settings.py配置</h4>
<p>新增内容
&#8220;` python
from urllib.parse import urlparse
import dj_database_url</p>

<p>redis_url = urlparse(os.environ.get(‘REDISTOGO_URL’, ‘redis://localhost:6959’))
CACHES = {
    ‘default’: {
        ‘BACKEND’: ‘redis_cache.cache.RedisCache’,
        ‘LOCATION’: ‘{0}:{1}’.format(redis_url.hostname, redis_url.port),
        ‘OPTIONS’: {
            ‘DB’: 0,
            ‘PASSWORD’: redis_url.password,
            ‘CLIENT_CLASS’: ‘redis_cache.client.DefaultClient’,
            ‘PICKLE_VERSION’: -1,  # Use the latest protocol version
            ‘SOCKET_TIMEOUT’: 60,  # in seconds
            ‘IGNORE_EXCEPTIONS’: True,
        }
    }
}</p>

<p>SESSION_ENGINE = ‘django.contrib.sessions.backends.cache’
SESSION_CACHE_ALIAS = ‘default’</p>

<h1 id="localsettingspy">本地开发配置放在local_settings.py中</h1>
<p>try:
    from .local_settings import *
except ImportError:
    pass
&#8220;`</p>

<h4 id="localsettingspy-1">local_settings.py配置</h4>
<p>这个是本地开发时候使用到的配置文件
&#8220;` python
DEBUG = True</p>

<p>CACHES = {
    ‘default’: {
        ‘BACKEND’: ‘redis_cache.cache.RedisCache’,
        ‘LOCATION’: ‘192.168.203.95:6379:1’,
        ‘OPTIONS’: {
            ‘CLIENT_CLASS’: ‘redis_cache.client.DefaultClient’,
            # ‘PASSWORD’: ‘secretpassword’,
            ‘PICKLE_VERSION’: -1,  # Use the latest protocol version
            ‘SOCKET_TIMEOUT’: 60,  # in seconds
            ‘IGNORE_EXCEPTIONS’: True,
        }
    }
}
&#8220;`</p>

<h3 id="section-1">使用方法</h3>

<h4 id="cachemanagerpy">cache_manager.py缓存管理器</h4>
<p>我们新建一个缓存管理器cache_manager.py，内容如下
&#8220;` python
#!/usr/bin/env python
# -<em>- encoding: utf-8 -</em>-
“””
Topic: redis缓存管理器
“””
from ..models import Post
from redis_cache import get_redis_connection
from apscheduler.schedulers.background import BackgroundScheduler</p>

<p>RUNNING_TIMER = False
REDIS_DB = get_redis_connection(‘default’)</p>

<p>def update_click(post):
    “”” 更新点击数 “””
    if REDIS_DB.hexists(“CLICKS”, post.id):
        print(‘REDIS_DB.hexists…’ + str(post.id))
        REDIS_DB.hincrby(‘CLICKS’, post.id)
    else:
        print(‘REDIS_DB.not_hexists…’ + str(post.id))
        REDIS_DB.hset(‘CLICKS’, post.id, post.click + 1)
    run_timer()</p>

<p>def get_click(post):
    “”” 获取点击数 “””
    if REDIS_DB.hexists(“CLICKS”, post.id):
        return REDIS_DB.hget(‘CLICKS’, post.id)
    else:
        REDIS_DB.hset(‘CLICKS’, post.id, post.click)
        return post.click</p>

<p>def sync_click():
    “&#8221;”同步文章点击数”””
    print(‘同步文章点击数start….’)
    for k in REDIS_DB.hkeys(‘CLICKS’):
        try:
            p = Post.objects.get(k)
            print(‘db_click={0}’.format(p.click))
            cache_click = get_click(p.id)
            print(‘cache_click={0}’.format(cache_click))
            if cache_click != p.click:
                p.click = get_click(p.id)
                p.save()
        except:
            pass
&#8220;`</p>

<h4 id="viewspy">views.py修改</h4>
<p>然后我们修改view.py，在相应的action里使用这个cache_manager：
&#8220;` python
from .commons import cache_manager</p>

<p>def post_list(request):
    “&#8221;”所有已发布文章”””
    posts = Post.objects.annotate(num_comment=Count(‘comment’)).filter(
        published_date__isnull=False).prefetch_related(
        ‘category’).prefetch_related(‘tags’).order_by(‘-published_date’)
    for p in posts:
        p.click = cache_manager.get_click(p)
    return render(request, ‘blog/post_list.html’, {‘posts’: posts})</p>

<p>def post_detail(request, pk):
    try:
        pass
    except:
        raise Http404()
    if post.published_date:
        cache_manager.update_click(post)
        post.click = cache_manager.get_click(post)
&#8220;`
其他的我就不多演示了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django1.7开发博客（12）- i18n国际化]]></title>
    <link href="http://yidao620c.github.io/blog/20150421/simpleblog-12.html"/>
    <updated>2015-04-21T19:27:29+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150421/simpleblog-12</id>
    <content type="html"><![CDATA[<h3 id="wiki">Wiki</h3>
<p>国际化与本地化的目的为了能为各个不同的用户以他们最熟悉的语言和格式来显示网页。</p>

<p>Django能完美支持文本翻译、日期时间和数字的格式化、时区。</p>

<p>另外，Django还有两点优势：</p>

<ol>
  <li>允许开发者和模板作者指定他们哪些app应该被翻译或被格式化为本地形式。</li>
  <li>允许用户根据自己的偏好来实现本地化显示。翻译依据语言，格式化依据国家，
这些信息由浏览器中的<code>Accept-Language</code>头来决定。不过目前为止时区还未能实现。</li>
</ol>

<p>参考官方文档：<a href="https://docs.djangoproject.com/en/1.7/topics/i18n/">https://docs.djangoproject.com/en/1.7/topics/i18n/</a></p>

<h3 id="section">配置</h3>
<p>实际上django的国际化做的非常好了，配置很简单。</p>

<h4 id="settingspy">settings.py</h4>
<p>首先在settings中，添加如下内容：<!--more-->
<code>python
from django.utils.translation import ugettext_lazy as _
LANGUAGES = (
    ('zh-cn', _('Simplified Chinese')),
    ('en', _('English')),
)
LOCALE_PATHS = (
    os.path.join(BASE_DIR, "locale"),
)
</code>
通过<code>LANGUAGES</code>执行语言列表，<code>LOCALE_PATHS</code>指定国际化目录。</p>

<p>在项目根目录下面创建一个locale文件夹，然后使用命令创建国际化文件：
<code>
django-admin.py makemessages -l zh_CN
</code></p>

<p>执行完后，locale文件夹下面创建<code>zh_CN/LC_MESSAGES/django.po</code>，里面的内容类似下面：</p>

<p>&#8220;` python
# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE’S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR.
#
#, fuzzy
msgid “”
msgstr “”
“Project-Id-Version: PACKAGE VERSION\n”
“Report-Msgid-Bugs-To: \n”
“POT-Creation-Date: 2014-11-26 11:45+0800\n”
“PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n”
“Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n”
“Language-Team: LANGUAGE <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#076;&#076;&#064;&#108;&#105;&#046;&#111;&#114;&#103;">&#076;&#076;&#064;&#108;&#105;&#046;&#111;&#114;&#103;</a>\n”
“MIME-Version: 1.0\n”
“Content-Type: text/plain; charset=UTF-8\n”
“Content-Transfer-Encoding: 8bit\n”
“Plural-Forms: nplurals=1; plural=0;\n”</p>

<h1 id="mysitesettingspy94">: .\mysite\settings.py:94</h1>
<p>msgid “Simplified Chinese”
msgstr “简体中文”</p>

<h1 id="mysitesettingspy95">: .\mysite\settings.py:95</h1>
<p>msgid “English”
msgstr “English”</p>

<h1 id="basehtml">: base.html</h1>
<p>msgid “Simple Blog”
msgstr “极简博客”</p>

<p>msgid “Hello”
msgstr “欢迎你”</p>

<p>msgid “previous”
msgstr “上一页”</p>

<p>msgid “next”
msgstr “下一页”</p>

<p>&#8220;`
将你页面上面需要翻译的内容写到这里面来即可。比如<code>previous</code>要翻译成<code>上一页</code>。</p>

<p>写好了所有的翻译后，再执行：
<code>
django-admin.py compilemessages
</code>
这时候会生成文件<code>zh_CN/LC_MESSAGES/django.mo</code>，这个是最终的目标文件了。</p>

<h3 id="section-1">使用</h3>
<p>我们用<code>base.html</code>来做演示，打开<code>mysite/templates/mysite/base.html</code></p>

<p>{% raw %}</p>

<p>&#8220;` html
{% load staticfiles %}
{% load i18n %}</p>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <title>{% trans &#8216;Simple Blog&#8217;%}</title>
</head>
<body class="customize-support">
<div class="page-header">
    {% if user.is_authenticated %}
        <a href="{% url 'post_new' %}" class="top-menu"><span class="glyphicon glyphicon-plus"></span></a>
        <a href="{% url 'post_draft_list' %}" class="top-menu"><span class="glyphicon glyphicon-edit"></span></a>
        <p class="top-menu" style="font-size: 15pt;">{% trans &#8216;Hello&#8217;%} {{ user.username }}
            <small>&nbsp;</small>
            <a href="{% url 'django.contrib.auth.views.logout' %}" class="top-menu">
                <span class="glyphicon glyphicon-log-out"></span></a>
        </p>
    {% else %}
        <a href="{% url 'django.contrib.auth.views.login' %}" class="top-menu">
            <span class="glyphicon glyphicon-log-in"></span></a>
    {% endif %}
    <h1><a href="{% url 'blog.views.post_list' %}">{% trans &#8216;Simple Blog&#8217;%}</a></h1>
</div>
&#8230;
</body>
</html>
<p>&#8220;`
{% endraw %}</p>

<p>注意{% raw %}<code>&lt;title&gt;{% trans 'Simple Blog'%}&lt;/title&gt;</code>{% endraw %}这句，
如果用户选择中文，那么就会被翻译成<code>极简博客</code>。
这个在django.po文件中定义过。其他的内容也是类似，就不多说了。</p>

<p>好了，i18n国际化就是这么简单。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django1.7开发博客（11）- 富文本与代码高亮]]></title>
    <link href="http://yidao620c.github.io/blog/20150421/simpleblog-11.html"/>
    <updated>2015-04-21T18:27:29+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150421/simpleblog-11</id>
    <content type="html"><![CDATA[<h2 id="tinymce">TinyMCE介绍</h2>
<p>TinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，支持目前流行的各种浏览器，由JavaScript写成。
功能配置灵活简单（两行代码就可以将编辑器嵌入网页中），支持AJAX。另一特点是加载速度非常快。</p>

<p>django里引用TinyMCE富文本编辑器，其实很简单，前提是你知道django的静态文件配置。
其实这个我已经在前面文章提到过，可以回去再看看。</p>

<p>TinyMCE的官方网站是：<a href="http://www.tinymce.com/">http://www.tinymce.com/</a></p>

<p>下载地址：<a href="http://download.moxiecode.com/tinymce/tinymce_4.1.9.zip">http://download.moxiecode.com/tinymce/tinymce_4.1.9.zip</a></p>

<p>TinyMCE的最新版本是4.1.9，下面是官网截屏：</p>

<p><img src="http://yidaospace.qiniudn.com/tinymce.png" alt="" /></p>

<p>下载下来后，我们把它解压到工程的static/目录下面，如下图所示：<!--more--></p>

<p><img src="http://yidaospace.qiniudn.com/dj101.png" alt="" /></p>

<h2 id="section">安装原理</h2>
<p>安装的原理很简单，只需要在使用编辑器的页面里引用tinymce.min.js文件并初始化就可以了。
tinymce.min.js文件在tinymce项目里，
tinymce.min.js会根据初始配置里的信息找到需要用编辑器的html节点。</p>

<p>例如在post_edit.html页面使用编辑器，只需要在模板文件写下：</p>

<p>{% raw %}</p>

<p><code>html
{% load staticfiles %}
{% block header %}
    &lt;link rel="stylesheet" href="{% static 'tinymce/plugins/upload/plugin.css' %}"&gt;
    &lt;script type="text/javascript" src="{% static 'tinymce/tinymce.min.js' %}"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
        tinymce.init({
            selector: "textarea",
            //width: 800,
            height: 300,
            forced_root_block: false,
            plugins: [
                "advlist autolink lists link image charmap print preview anchor sh4tinymce upload",
                "searchreplace visualblocks code fullscreen",
                "insertdatetime table contextmenu paste"
            ],
            toolbar: "insertfile undo redo | styleselect | bold italic | alignleft aligncenter" +
            " alignright alignjustify | bullist numlist outdent indent | preview link image sh4tinymce"
        });
    &lt;/script&gt;
{% endblock %}
</code>
{% endraw %}</p>

<p>这段代码的含义是 初始化 tinyMCE编辑器，selector指需要将编辑器显示在html那个标签节点，
这里选了textareas。则表示<textareas>会变成编辑器所在的位置。</textareas></p>

<p>另外，我还自定义一下编辑器的高度、插件、菜单项目等。具体详细配置请参考官方文档，写的都比较清楚。</p>

<h2 id="tinymceaddmore">给TinyMCE增加一个addmore插件</h2>
<p>需求很简单，就是每次我写文章的时候需要插入某个<code>&lt;!--more--&gt;</code>标签，
这样可以在列表页面先只显示文章的一部分，然后碰到这个more标签就显示一个”点击阅读更多”的链接。</p>

<p>第一步，在tinymce/plugins文件下新增一个addmore文件夹，然后在里面新建一个plugin.min.js文件，
内容如下：</p>

<p><code>
tinymce.PluginManager.add("addmore", function (a) {
    a.addCommand("InsertMoreRule", function () {
        a.execCommand("mceInsertContent", !1, "[!--more--]")
    }), a.addButton("addmore", {
        icon: "addmore",
        tooltip: "Insert More",
        cmd: "InsertMoreRule"
    }), a.addMenuItem("addmore", {
        icon: "addmore",
        text: "Insert More",
        cmd: "InsertMoreRule",
        context: "insert"
    })
});
</code></p>

<p>在post_edit.html中修改tinymce.init方法，plugins项目后面添加一个addmore：</p>

<pre><code>...
plugins: [
    "advlist autolink lists link image charmap print preview anchor sh4tinymce upload",
    "searchreplace visualblocks code fullscreen",
    "insertdatetime table contextmenu paste addmore"
],
...
</code></pre>

<p>再看看效果，没问题了。</p>

<h2 id="syntaxhighlighter">SyntaxHighlighter代码高亮</h2>
<p>程序员写博客当然少不了代码高亮，这个功能页很容易实现。有一款插件叫SyntaxHighlighter值的推荐。</p>

<p>项目主页：<a href="http://alexgorbatchev.com/SyntaxHighlighter/">http://alexgorbatchev.com/SyntaxHighlighter/</a></p>

<p>下载地址：<a href="http://alexgorbatchev.com/SyntaxHighlighter/download/download.php?sh_current">http://alexgorbatchev.com/SyntaxHighlighter/download/download.php?sh_current</a></p>

<p>下载下来后直接解压到static/目录下面，这个跟tinymce是一样的原理。</p>

<p><strong>使用方法</strong></p>

<p>只需要修改django页面的基础模板就行了，非常简单。</p>

<p>打开mysite/templates/mysite/base.html页面，引入syntaxhighlighter：
{% raw %}</p>

<p>&#8220;` html
{% load staticfiles %}
{% load i18n %}</p>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="{% static 'css/bootstrap.min.css' %}" />
    <!-- Optional theme -->
    <link rel="stylesheet" href="{% static 'css/bootstrap-theme.min.css' %}" />
    <!-- Blog CSS-->
    <link rel="stylesheet" href="{% static 'css/blog.css' %}" />
    <link type="text/css" rel="stylesheet" href="{% static 'syntaxhighlighter/styles/shCoreDefault.css' %}" />
    <script type="text/javascript" src="{% static 'syntaxhighlighter/scripts/shCore.js' %}"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="{% static 'js/jquery-1.11.1.min.js' %}"></script>
    <script src="{% static 'js/base.js' %}"></script>
    <script src="{% static 'js/bootstrap.min.js' %}"></script>
    {% block header %}
    {% endblock %}
    <title>{% trans &#8216;Simple Blog&#8217;%}</title>
</head>
<body class="customize-support">
中间省略&#8230;
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushJScript.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushBash.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushPhp.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushJava.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushSql.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushXml.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushPython.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushCss.js' %}"></script>
<script class="javascript" src="{% static 'syntaxhighlighter/scripts/shBrushCpp.js' %}"></script>
</body>
</html>
<p>&#8220;`
{% endraw %}</p>

<p>由于我们之前已经安装过了TinyMCE，这个跟它结合起来就非常好用了，因为TinyMCE自带有选择代码语言功能。</p>

<p>下面是我创建文章时，插入了一段python代码的示例：</p>

<p><img src="http://yidaospace.qiniudn.com/dj102.png" alt="" /></p>

<p>这个是保存后的效果：</p>

<p><img src="http://yidaospace.qiniudn.com/dj103.png" alt="" /></p>

<h2 id="section-1">最后一件事</h2>
<p>别忘了部署到Heroku上面和别人分享你的成果。</p>

<p>OK，到此为止，前台的各种功能已经差不多了，你能一直坚持学到这里很不错了，为你自己鼓掌吧。</p>

<p>后面还有一个重头戏，就是django的后台管理，我选择了更美观更好用的xamdin，敬请期待…</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django1.7开发博客（10）- 全文搜索]]></title>
    <link href="http://yidao620c.github.io/blog/20150421/simpleblog-10.html"/>
    <updated>2015-04-21T15:47:28+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150421/simpleblog-10</id>
    <content type="html"><![CDATA[<h3 id="wiki">Wiki：</h3>
<p>Django本身不提供全文检索的功能，但django-haystack为其提供了全文检索的框架。
django-haystack能为Django提供whoosh,solr,Xapian和Elasticsearc四种全文检索引擎作为后端。
其中whoosh为纯python的实现，不是非常大型的应用，是没有问题的。
本文将介绍Django1.7中通过django-haystack与whoosh集成以及whoosh的中文支持。</p>

<h3 id="section">安装依赖：</h3>
<p><code>
pip install django-haystack
pip install whoosh
pip install jieba
</code></p>

<h3 id="section-1">建立模型</h3>
<p>我们以文章为搜索目标，现在我的app名字为blog，
模型文件是mysite/blog/models.py ：<!--more--></p>

<p>&#8220;` python
# coding=utf-8
from django.db import models
@python_2_unicode_compatible
class Post(models.Model):
    class Meta:
        verbose_name = u’文章’
        verbose_name_plural = u’文章’
    # 作者
    author = models.ForeignKey(User)
    # 标题
    title = models.CharField(max_length=200)
    # 正文
    text = models.TextField()
    # 标签
    tags = models.ManyToManyField(Tag)
    # 分类目录
    category = models.ForeignKey(Category)
    # 点击量
    click = models.IntegerField(default=0)
    # 创建时间
    created_date = models.DateTimeField(default=timezone.now)
    # 发布时间
    published_date = models.DateTimeField(blank=True, null=True)</p>

<pre><code>def publish(self):
    self.published_date = timezone.now()
    self.save()

def __str__(self):
    return self.title ```
</code></pre>

<h3 id="searchindexespy">1. search_indexes.py</h3>
<p>在app目录下建立一个search_indexes.py（mysite/blog/search_indexes.py）代码如下：</p>

<p>&#8220;` python
#!/usr/bin/env python
# -<em>- encoding: utf-8 -</em>-
from models import Post
from haystack import indexes
class PostIndex(indexes.SearchIndex, indexes.Indexable):
    text = indexes.CharField(document=True, use_template=True)
    # 对title字段进行索引
    title = indexes.CharField(model_attr=’title’)
    def get_model(self):
        return Post</p>

<pre><code>def index_queryset(self, using=None):
    return self.get_model().objects.all() ```
</code></pre>

<p><em>备注</em>：search_indexes.py文件名不能修改，否则报错：<code>No fields were found in any search_indexes.</code></p>

<h3 id="posttexttxt">2. post_text.txt</h3>
<p>因为在search_indexes.py使用了use_template=True，所以可以同时使用模板对索引字段进行定义。</p>

<p>如：<code>mysite/blog/templates/search/indexes/blog/post_text.txt</code>:</p>

<p><code>
{{ object.title }}
{{ object.text }}
</code></p>

<h3 id="settingspy">3. settings.py</h3>

<p><code>python
# Application definition
INSTALLED_APPS = (
    ...
    'haystack',
)
</code></p>

<h3 id="urlspy">4. urls.py</h3>

<p><code>python
urlpatterns = patterns(
    '',
    url(r'^admin/', include(admin.site.urls)),
    url(r'^xadmin/', include(xadmin.site.urls), name='xadmin'),
    url(r'^accounts/login/$', 'django.contrib.auth.views.login'),
    url(r'^accounts/logout/$', 'django.contrib.auth.views.logout', {'next_page': '/'}),
    url(r'^search/', include('haystack.urls')),
    url(r'', include('blog.urls')),
)
</code></p>

<h3 id="jieba">5. jieba中文分词</h3>
<p>jieba其实已经提供了集成whoosh的ChineseAnalyzer，
也就是说不需要自己写ChineseAnalyzer了，直接在whoosh_backend.py中直接引用就好；
同时，不推荐将whoosh_backend.py放到Lib下面，这样移植性会有问题，自己的代码，还是放在项目下面为妙。</p>

<p>1. 将文件whoosh_backend.py拷贝到app下面，并重命名为whoosh_cn_backend.py，
如blog/whoosh_cn_backend.py。重点的改造有：</p>

<ul>
  <li>增加：
<code>python
from jieba.analyse import ChineseAnalyzer
</code></li>
  <li>修改
<code>python
schema_fields[field_class.index_fieldname] = TEXT(stored=True, analyzer=ChineseAnalyzer(),
 field_boost=field_class.boost, sortable=True)
</code>
2. 修改后端引擎，setting.py配置：</li>
</ul>

<p><code>python
# full text search
HAYSTACK_CONNECTIONS = {
    'default': {
        'ENGINE': 'blog.whoosh_cn_backend.WhooshEngine',
        'PATH': os.path.join(BASE_DIR, 'whoosh_index'),
    },
}
</code>
### 6. 重建索引</p>

<p><code>python
python manage.py rebuild_index
</code>
### 7. 索引更新
最简单的办法就是在settings.py中添加：
<code>python
HAYSTACK_SIGNAL_PROCESSOR = 'haystack.signals.RealtimeSignalProcessor'
</code>
### 8. 自定义搜索示例
(1) 先定义view：</p>

<p><code>python
from haystack.forms import SearchForm
def full_search(request):
    """全局搜索"""
    keywords = request.GET['q']
    sform = SearchForm(request.GET)
    posts = sform.search()
    return render(request, 'blog/post_search_list.html',
                  {'posts': posts, 'list_header': '关键字 \'{}\' 搜索结果'.format(keywords)})
</code></p>

<p>(2) 然后在template页面中：
{% raw %}</p>

<p>&#8220;` html
<!-- searchbox START --></p>
<div id="searchbox">
    <form action="{% url 'blog.views.full_search' %}" method="get">
        <div class="content">
            <label>
                <input type="text" class="textfield searchtip" name="q" size="24" value="" />
            </label>
            <input type="submit" class="button" value="" />
        </div>
    </form>
</div>
<p>&#8220;`
{% endraw %}</p>

<p>更详细内容请参考官方文档：<a href="http://django-haystack.readthedocs.org/en/latest/">http://django-haystack.readthedocs.org/en/latest/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django1.7开发博客（9）- 用户认证]]></title>
    <link href="http://yidao620c.github.io/blog/20150421/simpleblog-09.html"/>
    <updated>2015-04-21T14:47:47+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150421/simpleblog-09</id>
    <content type="html"><![CDATA[<h2 id="section">安全问题</h2>
<p>你应该注意到了一点，当你去新建、修改和删除文章的时候并不需要登录，
这样的话任何浏览网站的用户都能随时修改和删除我的文章。这个可不是我想要的！</p>

<h2 id="section-1">编辑和删除的认证</h2>
<p>我们需要保护post_new, post_edit和post_publish这三个视图，只有登录用户才有权去执行。
django为我们提供了很好的帮助类，其实就是利用了python中的decorators技术。
django中认证的装饰器位于模块django.contrib.auth.decorators中，名称叫login_required。</p>

<p>编辑blog/views.py文件，在import部分添加如下的导入语句：
<code>python
from django.contrib.auth.decorators import login_required
</code></p>

<p>然后在post_new, post_edit和post_publish这三个函数上添加@login_required，
类似下面<!--more-->
<code>python
@login_required
def post_new(request):
    [...]
</code></p>

<p>好的，现在你再去访问下http://localhost:8000/post/new/，看看有啥变化。</p>

<p>注：如果你仍然能正常进入新建页面，那可能是你之前在admin界面登陆过。
那么你需要先退出，访问http://localhost:8000/admin/logout/可以退出，然后你再看下效果。</p>

<p>我刚刚添加的@login_required装饰器检测到你尚未登陆的时候会重定向到login页面，
但是我现在还没有定义login的模板页面，所以这时候会是404错误页面。</p>

<h2 id="section-2">用户登录</h2>
<p>django在用户认证方面做得很好了，我们只需要去使用它就行。</p>

<p>在mysite/urls.py文件中，添加下面一行
<code>python
url(r'^accounts/login/$', 'django.contrib.auth.views.login')
</code>
现在这个文件内容如下：
&#8220;` python
from django.conf.urls import patterns, include, url</p>

<p>from django.contrib import admin
admin.autodiscover()</p>

<p>urlpatterns = patterns(‘’,
    url(r’^admin/’, include(admin.site.urls)),
    url(r’^accounts/login/$’, ‘django.contrib.auth.views.login’),
    url(r’’, include(‘blog.urls’)),
)
&#8220;`</p>

<p>然后我们再定义一个登陆页面，创建目录mysite/templates/registration，
并在里面新建模板文件login.html，内容如下：</p>

<p>{% raw %}</p>

<p>&#8220;` html
{% extends “mysite/base.html” %}</p>

<p>{% block content %}</p>

<pre><code>{% if form.errors %}
&lt;p&gt;Your username and password didn't match. Please try again.&lt;/p&gt;
{% endif %}

&lt;form method="post" action="{% url 'django.contrib.auth.views.login' %}"&gt;
{% csrf_token %}
&lt;table&gt;
&lt;tr&gt;
    &lt;td&gt;{{ form.username.label_tag }}&lt;/td&gt;
    &lt;td&gt;{{ form.username }}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;{{ form.password.label_tag }}&lt;/td&gt;
    &lt;td&gt;{{ form.password }}&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;input type="submit" value="login" /&gt;
&lt;input type="hidden" name="next" value="{{ next }}" /&gt;
&lt;/form&gt; {% endblock %} ``` {% endraw %}
</code></pre>

<p>你可以看到我们仍然使用到了模板继承。这个时候可以定义一个mysite/templates/mysite/base.html，
把blog/templates/blog/base.html的内容复制给它即可。</p>

<p>不过我们需要在mysite/settings.py中再添加一个urls配置：
<code>python
LOGIN_REDIRECT_URL = '/'
</code>
这样的话当用户直接访问login页面后登录成功会重定向到文章列表页面去。</p>

<h2 id="section-3">改进显示</h2>
<p>现在的确只有登录用户才能修改和删除文章，但是未登录用户却能看到这些按钮，
这个是很不好的体验。现在如果是未登录用户的话就把这些按钮给隐藏掉。</p>

<p>因此我们修改mysite/templates/mysite/base.html如下：
{% raw %}</p>

<p>&#8220;` html</p>
<body>
    <div class="page-header">
        {% if user.is_authenticated %}
        <a href="{% url 'post_new' %}" class="top-menu"><span class="glyphicon glyphicon-plus"></span></a>
        <a href="{% url 'post_draft_list' %}" class="top-menu"><span class="glyphicon glyphicon-edit"></span></a>
        {% else %}
        <a href="{% url 'django.contrib.auth.views.login' %}" class="top-menu"><span class="glyphicon glyphicon-lock"></span></a>
        {% endif %}
        <h1><a href="{% url 'blog.views.post_list' %}">Django Girls</a></h1>
    </div>
    <div class="content">
        <div class="row">
            <div class="col-md-8">
            {% block content %}
            {% endblock %}
            </div>
        </div>
    </div>
</body>
<p>&#8220;`
{% endraw %}</p>

<p>然后修改blog/templates/blog/post_detail.html如下：
{% raw %}</p>

<p>&#8220;` html
{% extends ‘blog/base.html’ %}</p>

<p>{% block content %}
    &lt;div class=&#8221;date&#8221;&gt;
        {% if post.published_date %}
            {{ post.published_date }}
        {% else %}
            {% if user.is_authenticated %}
                <a class="btn btn-default" href="{% url 'blog.views.post_publish' pk=post.pk %}">Publish</a>
            {% endif %}
        {% endif %}
        {% if user.is_authenticated %}
            <a class="btn btn-default" href="{% url 'post_edit' pk=post.pk %}"><span class="glyphicon glyphicon-pencil"></span></a>
            <a class="btn btn-default" href="{% url 'post_remove' pk=post.pk %}"><span class="glyphicon glyphicon-remove"></span></a>
        {% endif %}
    &lt;/div&gt;
    &lt;h1&gt;{{ post.title }}&lt;/h1&gt;
    &lt;p&gt;{{ post.text|linebreaks }}&lt;/p&gt;
{% endblock %}
&#8220;`
{% endraw %}</p>

<h2 id="section-4">用户注销</h2>
<p>当用户登录后显示欢迎语句，Hello ，然后后面跟一个logout链接。还是依靠django帮我们处理logout动作。</p>

<p>修改mysite/templates/mysite/base.html文件如下：
{% raw %}</p>

<p>&#8220;` html</p>
<div class="page-header">
    {% if user.is_authenticated %}
    <a href="{% url 'post_new' %}" class="top-menu"><span class="glyphicon glyphicon-plus"></span></a>
    <a href="{% url 'post_draft_list' %}" class="top-menu"><span class="glyphicon glyphicon-edit"></span></a>
    <p class="top-menu">Hello {{ user.username }}<small>&nbsp;<a href="{% url 'django.contrib.auth.views.logout' %}">Log out</a>
    {% else %}
    <a href="{% url 'django.contrib.auth.views.login' %}" class="top-menu"><span class="glyphicon glyphicon-lock"></span></a>
    {% endif %}
    <h1><a href="{% url 'blog.views.post_list' %}">Django Girls</a></h1>

&#8220;`
{% endraw %}

很显然这时候logout肯定会报错。我们还得做些事情。

对于这方面的详细文档请参考：&lt;https://docs.djangoproject.com/en/1.7/topics/auth/default/&gt;

打开mysite/urls.py文件，添加一个logout配置：
&#8220;` python
from django.conf.urls import patterns, include, url

from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns(&#8221;,
    url(r&#8217;^admin/&#8217;, include(admin.site.urls)),
    url(r&#8217;^accounts/login/$&#8217;, &#8216;django.contrib.auth.views.login&#8217;),
    url(r&#8217;^accounts/logout/$&#8217;, &#8216;django.contrib.auth.views.logout&#8217;, {&#8216;next_page&#8217;: &#8216;/&#8217;}),
    url(r&#8221;, include(&#8216;blog.urls&#8217;)),
)
&#8220;`
如果访问网站时出现模板找不到错误，那么你就在mysite/settings.py中添加如下配置：
&#8220;` python
# TEMPLATE_DIRS
TEMPLATE_DIRS = (
    os.path.join(BASE_DIR, &#8216;mysite/templates&#8217;),
    os.path.join(BASE_DIR, &#8216;blog/templates&#8217;),
)
&#8220;`

好的，现在你已经可以达成如下的效果了：

1. 需要一个用户名和密码登录系统
1. 在添加/编辑/删除/发布文章的时候需要登录
1. 也能注销

这么说的话，这个博客系统算功能比较完善了！朋友，祝福你。
</small></p></div>
]]></content>
  </entry>
  
</feed>
