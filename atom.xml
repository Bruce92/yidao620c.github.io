<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[笨跑的一刀]]></title>
  <link href="http://yidao620c.github.io/atom.xml" rel="self"/>
  <link href="http://yidao620c.github.io/"/>
  <updated>2015-04-13T19:21:27+08:00</updated>
  <id>http://yidao620c.github.io/</id>
  <author>
    <name><![CDATA[熊能]]></name>
    <email><![CDATA[yidao620@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[centos6更新yum源]]></title>
    <link href="http://yidao620c.github.io/blog/20150413/centos-yum.html"/>
    <updated>2015-04-13T19:02:42+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150413/centos-yum</id>
    <content type="html"><![CDATA[<h4 id="section">先备份</h4>

<p><code>
mv /etc/yum.repos.d/CentOS-Base.repo{,.bak}
</code></p>

<h4 id="centos-baserepo">修改CentOS-Base.repo</h4>

<pre><code># CentOS-Base.repo
#
# The mirror system uses the connecting IP address of the client and the
# update status of each mirror to pick mirrors that are updated to and
# geographically close to the client. You should use this for CentOS updates
# unless you are manually picking other mirrors.
#
# If the mirrorlist= does not work for you, as a fall back you can try the 
# remarked out baseurl= line instead.
#
#
 
[base]
name=CentOS-$releasever - Base
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os
baseurl=http://mirrors.163.com/centos/$releasever/os/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
  
#released updates 
[updates]
name=CentOS-$releasever - Updates
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates
baseurl=http://mirrors.163.com/centos/$releasever/updates/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
  
#additional packages that may be useful
[extras]
name=CentOS-$releasever - Extras
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras
baseurl=http://mirrors.163.com/centos/$releasever/extras/$basearch/
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
  
#additional packages that extend functionality of existing packages
[centosplus]
name=CentOS-$releasever - Plus
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus
baseurl=http://mirrors.163.com/centos/$releasever/centosplus/$basearch/
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
  
#contrib - packages by Centos Users
[contrib]
name=CentOS-$releasever - Contrib
#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=contrib
baseurl=http://mirrors.163.com/centos/$releasever/contrib/$basearch/
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
</code></pre>

<p>接下来我们来更新下yum：</p>

<pre><code>yum clean all
yum makecache #将服务器上的软件包信息缓存到本地,以提高搜索安装软件的速度
yum install vim*#测试域名是否可用
</code></pre>

<h4 id="rpmforge">附：增加RPMforge源</h4>
<ol>
  <li>download the rpmforge package:
<a href="http://packages.sw.be/rpmforge-release/rpmforge-release-0.5.2-2.el6.rf.i686.rpm">http://packages.sw.be/rpmforge-release/rpmforge-release-0.5.2-2.el6.rf.i686.rpm</a></li>
  <li>Install DAG’s GPG key
 <code>sudo rpm --import http://apt.sw.be/RPM-GPG-KEY.dag.txt</code>
如果上面出现错误，确认下：
 <code>sudo rpm -K rpmforge-release-0.5.2-2.el6.rf.*.rpm</code></li>
  <li>然后安装rpm
 <code>sudo rpm -i rpmforge-release-0.5.2-2.el6.rf.*.rpm</code></li>
  <li>试试看：
 <code>sudo yum install htop</code></li>
  <li>开始更新系统：
 <code>sudo yum update</code></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[servlet filter详解]]></title>
    <link href="http://yidao620c.github.io/blog/20150406/servlet-filter.html"/>
    <updated>2015-04-06T21:08:25+08:00</updated>
    <id>http://yidao620c.github.io/blog/20150406/servlet-filter</id>
    <content type="html"><![CDATA[<p>在写一个springmvc项目中想对用户的请求进行拦截，只有登录用户才能访问资源。这时候可以使用到SpringMVC的拦截器Intercepter，但是这个只能局限在SpringMVC中使用，如果想更加通用一点，最好使用Servlet Filter实现这个需求。</p>

<p>本文将通过几个实际的例子展示下Servlet中的Filter的使用。</p>

<p>1). 我们为什么需要使用Filter？</p>

<p>通常我们会使用session来保存登录用户的信息，通过从session中取出保存的属性值来判断用户是否登录，但是如果我们有大量的请求方法，每个人方法中都这样去判断就会有很多重复代码，将来我们想改动下逻辑，那得改动所有的请求方法实现，所以这个是不可取的。</p>

<p>这时候就是使用Servlet Filter的时候了，它是可插拔的，对于普通的action方法来讲是透明的。它会在执行其他方法之前或将结果返回给客户端之前来执行其他逻辑。</p>

<p>以下几种场景下我们会使用到Servlet Filter：</p>

<ul>
  <li>将请求的参数写入日志文件</li>
  <li>对于资源的访问进行统一的授权与验证</li>
  <li>在请求到达实际Servlet之前格式化请求内容或请求头</li>
  <li>压缩返回数据后发送给客户端</li>
  <li>修改返回内容，增加一些cookie、header等信息<!--more--></li>
</ul>

<p>前面提到过，Servlet是可插拔的，可以通过在web.xml中配置是否使用。如果我们定义了多个Filter，就会形成一个过滤器链。
通过实现接口javax.servlet.Filter来创建一个过过滤器。</p>

<p>2).  Filter接口</p>

<p>Filter接口包含了三个跟生命周期有关的方法，并且由Servlet容器来管理。它们分别是：</p>
]]></content>
  </entry>
  
</feed>
