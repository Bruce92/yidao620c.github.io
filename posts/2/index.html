
<!DOCTYPE HTML>

<html>

<head>
	<meta charset="utf-8">
	<title>笨跑的一刀</title>
	<meta name="author" content="熊能">

	
	<meta name="description" content="2015-04-20 rabbitmq CentOS6.4安装rabbitmq-server 在 CentOS 6.4上安装python
自己手动安装python2.7.5，不要动系统上面其他的版本 1,先安装GCC，用如下命令yum install gcc gcc-c++
1
2
yum &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="笨跑的一刀" type="application/atom+xml">
	
	<link rel="canonical" href="http://yidao620c.github.io/posts/2/index.html">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<link href='http://fonts.useso.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'>
	<script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js"></script>
	
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">
	<img src="/images/profile.jpg" alt="Profile Picture" style="width: 160px;" />
</div>
<hgroup>
  <h1><a href="/">笨跑的一刀</a></h1>
  
    <h2>Code is sexy, like Amy!</h2>
  
</hgroup>
<nav id="main-nav"><ul class="main">
    <li><a href="/">Home</a></li>
	<li><a href="/blog/categories">标签云</a></li>
	<li><a href="/blog/archives">文章列表</a></li>
    <li><a href="/opensource/">开源项目</a></li>
    <li><a href="/about">About</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
			<a class="email" href="mailto:yidao620@gmail.com" title="Email">Email</a>
		
		
		
			<a class="google" href="https://plus.google.com/yidao620@gmail.com" rel="author" title="Google+">Google+</a>
		
		
			<a class="twitter" href="http://twitter.com/yidao620@gmail.com" title="Twitter">Twitter</a>
		
		
			<a class="github" href="https://github.com/yidao620c" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		
		
		
    	
    	
			<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


2015-04-20</div>
		<div class="tags">


	<a class='category' href='/blog/categories/rabbitmq/'>rabbitmq</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150420/rabbitmq-server.html" itemprop="url">CentOS6.4安装rabbitmq-server</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h3 id="centos-64python">在 CentOS 6.4上安装python</h3>
<p>自己手动安装python2.7.5，不要动系统上面其他的版本</p>

<p><strong>1,先安装GCC，用如下命令yum install gcc gcc-c++</strong></p>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">yum install zlib
</span><span class="line">yum install zlib-devel</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><strong>2,下载 <a href="https://www.python.org/ftp/python/2.7.5/Python-2.7.5.tgz">python-2.7.5.tar.gz</a> 文件，修改文件权限</strong></p>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">chmode +x python-7.5.tar.gz</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><strong>3,解压tar文件</strong></p>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">tar -xzvf python-2.7.5.tar.gz</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><strong>4,编辑Setup.dist</strong></p>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd python-2.7.5
</span><span class="line">vim Python-2.7.5/Modules/Setup.dist</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>找到
		
		<a href="/blog/20150420/rabbitmq-server.html" class="more-link">「阅读全文」&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


2015-04-20</div>
		<div class="tags">


	<a class='category' href='/blog/categories/sort/'>sort</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150420/merge-sort.html" itemprop="url">归并排序中对小数组采用插入排序</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>纯归并排序的复杂度为O(nlgn)，而纯插入排序的时间复杂度为O(n^2)。数据量很大的时候采用归并排序。</p>

<p>但是在n较小的时候插入排序可能运行的会更快点。因此在归并排序中当子问题变得足够小时，
采用插入排序来使得递归的叶子变粗可以加快排序速度。那么这个足够小到底怎么去衡量呢？ 请看下面：</p>

<p>这么几个我不证明了，比较简单：</p>

<ol>
  <li>插入排序最坏情况下可以在O(nk)时间内排序每个长度为k的n/k个子列表
*. 在最坏情况下可在O(nlg(n/k))的时间内合并这些子表
*. 修订后的算法的最坏情况运行时间复杂度是O(nk + nlg(n/k))</li>
</ol>

<p>那么，O(nk+nlg(n/k))=O(nlgn).只能最大是k=O(lgn).等式左边中第一项是高阶项。
k如果大于lgn,则比归并排序复杂度大了。
左边可以写成nk+nlgn-nlgk，k等于lgn时，就是2nlgn-nlglgn.忽略恒定系数，则与归并排序是一样的。
最后结论： k &lt; lg(n)的时候，使用插入排序。
		
		<a href="/blog/20150420/merge-sort.html" class="more-link">「阅读全文」&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


2015-04-18</div>
		<div class="tags">


	<a class='category' href='/blog/categories/eight-queens/'>eight-queens</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150418/eight-queens.html" itemprop="url">回溯法解决八皇后问题</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解 — 摘自<a href="http://zh.wikipedia.org/wiki/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98">八皇后问题wiki</a></p>

<p>利用回溯法解决这个问题：
		
		<a href="/blog/20150418/eight-queens.html" class="more-link">「阅读全文」&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


2015-04-18</div>
		<div class="tags">


	<a class='category' href='/blog/categories/redis/'>redis</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150418/redis-install.html" itemprop="url">Redis入门与安装</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2 id="redis">一 Redis介绍</h2>

<p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。</p>

<p>Redis能运行在大多数POSIX(Linux, *BSD, OS X 和Solaris等)系统上，官方没有支持Windows的版本。目前最新的版本是2.2.11，这个版本主要是修复了一个2.2.7版本中遍历方式优化带来的一个bug。</p>

<p>和普通的Key-Value结构不同，Redis的Key支持灵活的数据结构，除了strings，还有hashes、lists、 sets 和sorted sets等结构。正是这些灵活的数据结构，丰富了Redis的应用场景，能满足更多业务上的灵活存储需求。</p>

<p>Redis的数据都保存在内存中，而且底层实现上是自己写了epoll event loop部分，而没有采用开源的libevent等通用框架，所以读写效率很高。
为了实现数据的持久化，Redis支持定期刷新(可通过配置实现)或写日志的方式来保存数据到磁盘。</p>

<p><strong>1. 数据类型</strong></p>

<p>作为Key-value型数据库，Redis也提供了键(Key)和键值(Value)的映射关系。但是，除了常规的数值或字符串，Redis的键值还可以是以下形式之一：</p>

<ul>
  <li>Lists (列表)</li>
  <li>Sets (集合)</li>
  <li>Sorted sets (有序集合)</li>
  <li>Hashes (哈希表)
		
		<a href="/blog/20150418/redis-install.html" class="more-link">「阅读全文」&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


2015-04-18</div>
		<div class="tags">


	<a class='category' href='/blog/categories/memcached/'>memcached</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150418/xmemecached.html" itemprop="url">使用xmemcached客户端</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>Xmemcached是基于java nio实现的高性能可扩展的memcached客户端。它的主要特点：</p>

<ol>
  <li>高性能，稳定可靠，已经在众多公司的众多项目里得到应用。</li>
  <li>功能完备：客户端分布式、权重、最新最完整的协议支持。</li>
  <li>可扩展，易于集成</li>
  <li>可动态增删memached节点</li>
  <li>客户端操作统计</li>
  <li>NIO连接池</li>
</ol>

<p>等等，更多信息请见wiki文档。废话不多讲，先上代码：
		
		<a href="/blog/20150418/xmemecached.html" class="more-link">「阅读全文」&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


2015-04-18</div>
		<div class="tags">


	<a class='category' href='/blog/categories/memcached/'>memcached</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150418/memcached-install.html" itemprop="url">Linux上安装memcached</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p><strong>一 准备安装文件</strong></p>

<p>下载memcached与libevent的安装文件：</p>

<p>memcached下载地址：<a href="http://memcached.googlecode.com/files/memcached-1.4.15.tar.gz">memcached-1.4.15.tar.gz</a></p>

<p>libevent下载地址：<a href="https://github.com/downloads/libevent/libevent/libevent-2.0.21-stable.tar.gz">libevent-2.0.21-stable.tar.gz</a></p>

<p><strong>二 具体安装步骤</strong></p>

<ol>
  <li>由于memcached依赖于libevent，因此需要安装libevent。由于linux系统可能默认已经安装libevent，执行命令：</li>
</ol>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rpm -qa|grep libevent </span></code></pre></td></tr></table></div></figure></notextile></div>
<ol>
  <li>查看系统是否带有该安装软件，如果有执行命令:</li>
</ol>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line"># 由于系统自带的版本旧，忽略依赖删除
</span><span class="line">rpm -e libevent-1.4.13-4.el6.x86_64 –nodeps</span></code></pre></td></tr></table></div></figure></notextile></div>
<ol>
  <li>安装libevent命令：
		
		<a href="/blog/20150418/memcached-install.html" class="more-link">「阅读全文」&rarr;</a>
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


2015-04-18</div>
		<div class="tags">


	<a class='category' href='/blog/categories/puzzle/'>puzzle</a>, <a class='category' href='/blog/categories/recursive/'>recursive</a>


</div>
		
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/20150418/concurrent-recursive.html" itemprop="url">利用递归算法并行化解决谜题框架</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>我们将谜题定义为：包含一个初始位置，一个目标位置，以及用于判断是否是有效移动的规则集。</p>

<p>规则集包含两部分：计算从指定位置开始的所有合法移动，以及每次移动的结果位置。</p>

<p>下面先给出表示谜题的抽象类，其中的类型参数P和M表示位置类和移动类。根据这个接口，我们可以写一个简单的串行求解程序，该程序将在谜题空间Puzzle Space中查找，直到找到一个解答或者找遍了整个空间都没有发现答案。注：一个移动M代表一步</p>
<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="cm">/** 表示 搬箱子 之类谜题的抽象类*/</span>
</span><span class="line"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Puzzle</span><span class="o">&lt;</span><span class="n">P</span><span class="o">,</span> <span class="n">M</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class="line">    <span class="n">P</span> <span class="nf">initialPosition</span><span class="o">();</span>
</span><span class="line">
</span><span class="line">    <span class="kt">boolean</span> <span class="nf">isGoal</span><span class="o">(</span><span class="n">P</span> <span class="n">position</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">Set</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;</span> <span class="nf">legalMoves</span><span class="o">(</span><span class="n">P</span> <span class="n">position</span><span class="o">);</span>
</span><span class="line">
</span><span class="line">    <span class="n">P</span> <span class="nf">move</span><span class="o">(</span><span class="n">P</span> <span class="n">position</span><span class="o">,</span> <span class="n">M</span> <span class="n">move</span><span class="o">);</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>下面的PuzzleNode代表通过一系列的移动到达的一个位置，其中保存了到达该位置的移动以及前一个Node。只要沿着PuzzleNode链接逐步回溯，就可以重新构建出达到当前位置的移动序列。
		
		<a href="/blog/20150418/concurrent-recursive.html" class="more-link">「阅读全文」&rarr;</a>
	</div>

</article>

</div>
<nav id="pagenavi">
    
        
        <a href="/" class="prev">Prev</a>
        
    
    
        <a href="/posts/3" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner">Copyright &copy; 2015

    熊能


Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
		</div>
	</div>
	







</body>
</html>
